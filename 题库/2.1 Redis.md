# **Redis**

### 1.redis缓存扩展机制如何实现：

------

​	字典中哈希表的rehash函数(重新散列)操作。

### 2.redis的常用数据结构：

------

string,
list,
sorted set,(Zset)
set,
hash(map套map)

### 3.redis的最大存储键值对量

------

​	百度答案:2^32-1

### 4.redis在项目中是如何应用的

------

作为缓存中间件，消息过来先查redis，redis没有再从硬盘里/网盘里找

### 5.什么是redis持久化

------

redis中的数据存在内从中，把内存中的数据保存到本地硬盘中，就是redis的持久化

有两种方式，

1.rdb:将某一时刻的内存数据，以二进制的方式写入磁盘(在某个时刻存数据)

 2.aof:每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；（保存写命令）

3.混合持久化方式：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；

### 6.解释一下redis缓存雪崩，缓存击穿，缓存穿透？缓存预热?

------

缓存雪崩：**同一时间大量热点请求redis，且都无法在redis中找到**，这些请求被转到服务器端。服务器压力变大。

answer：大量热点数据在同一时间失效**，导致本来可以在缓存中找到的数据，现在只能到底层数据库进行查询，这样多个请求会直接到底层数据库访问数据，磁盘IO的次数会剧增。



缓存击穿：

answer：某**一个热点数据**从缓存中失效了，此时大量请求过来之后，就无法在缓存中获取数据，此时大量请求就只能在底层数据库去获取数据，磁盘IO的次数会剧增。数据库很容易就被高并发的请求冲垮导致底层数据库的压力很大。



缓存穿透：

**访问的数据在缓存里面不存在，然后在底层数据库中也不存在**，也就是：访问的数据本身就是一个不存在的数据，那所有的访问请求都会到底层数据库，而数据本身不存在，所以永远找不到。



缓存预热：

缓存预热并不是一个问题，而是使用缓存时的一个优化方案，它可以提高前台用户的使用体验。缓存预热指的是在系统启动的时候，先把查询结果预存到缓存中，以便用户后面查询时可以直接从缓存中读取，以节约用户的等待时间





### 9.redis常见基础类型

------



```
string,
list,
sorted set
set
hash(map套map)
```

### 10.reids部署的一个还是多个?主从复制和哨兵模式的原理？

------

一个

由于数据都是存储在一台服务器上，如果出事就完犊子了。

要避免这种单点故障，最好的办法是将数据备份到其他服务器上，让这些服务器也可以对外提供服务，这样即使有一台服务器出现了故障，其他服务器依然可以继续提供服务。



主从复制共有三种模式：**全量复制、基于长连接的命令传播、增量复制**。

主从服务器第一次同步的时候，就是采用**全量复制**，此时主服务器会两个耗时的地方，分别是生成 RDB 文件和传输 RDB 文件。为了避免过多的从服务器和主服务器进行全量复制，可以把一部分从服务器升级为「经理角色」，让它也有自己的从服务器，通过这样可以分摊主服务器的压力。

第一次同步完成后，主从服务器都会**维护着一个长连接**，主服务器在接收到写操作命令后，就会通过这个连接将写命令传播给从服务器，来保证主从服务器的数据一致性。

如果遇到网络断开，**增量复制**就可以上场了，不过这个还跟 repl_backlog_size 这个大小有关系。

如果它配置的过小，主从服务器网络恢复时，可能发生「从服务器」想读的数据已经被覆盖了，那么这时就会导致主服务器采用全量复制的方式。所以为了避免这种情况的频繁发生，要调大这个参数的值，以降低主从服务器断开后全量同步的概率。



##### **主从复制：**

主服务器可以进行读写操作，当发生写操作时自动将写操作同步给从服务器，而从服务器一般是只读，并接受主服务器同步过来写操作命令，然后执行这条命令。

![图片](https://img-blog.csdnimg.cn/img_convert/2b7231b6aabb9a9a2e2390ab3a280b2d.png)

所有的数据修改只在主服务器上进行，然后将最新的数据同步给从服务器，这样就使得主从服务器的数据是一致的。

主从服务器间的第一次同步的过程可分为三个阶段：

- 第一阶段是建立链接、协商同步；
- 第二阶段是主服务器同步数据给从服务器；
- 第三阶段是主服务器发送新写操作命令给从服务器。

主从服务器在完成第一次同步后，双方之间就会维护一个 TCP 连接。

**分摊主服务器的压力**

主服务器是可以有多个从服务器的，如果从服务器数量非常多，而且都与主服务器进行全量同步的话，就会带来两个问题：

- 由于是通过 bgsave 命令来生成 RDB 文件的，那么主服务器就会忙于使用 fork() 创建子进程，如果主服务器的内存数据非大，在执行 fork() 函数时是会阻塞主线程的，从而使得 Redis 无法正常处理请求；
- 传输 RDB 文件会占用主服务器的网络带宽，会对主服务器响应命令请求产生影响。

Redis从服务器可以有自己的从服务器，我们可以把拥有从服务器的从服务器当作经理角色，它不仅可以接收主服务器的同步数据，自己也可以同时作为主服务器的形式将数据同步给从服务器，组织形式如下图：

![图片](https://img-blog.csdnimg.cn/img_convert/4d850bfe8d712d3d67ff13e59b919452.png)

**增量复制**

如果主从服务器间的网络连接断开了，那么就无法进行命令传播了，这时从服务器的数据就没办法和主服务器保持一致了，客户端就可能从「从服务器」读到旧的数据。

从 Redis 2.8 开始，网络断开又恢复后，从主从服务器会采用**增量复制**的方式继续同步，也就是只会把网络断开期间主服务器接收到的写操作命令，同步给从服务器。

关键的问题来了，**主服务器怎么知道要将哪些增量数据发送给从服务器呢？**

答案藏在这两个东西里：

- **repl_backlog_buffer**，是一个「**环形**」缓冲区，用于主从服务器断连后，从中找到差异的数据；
- **replication offset**，标记上面那个缓冲区的同步进度，主从服务器都有各自的偏移量，主服务器使用 master_repl_offset 来记录自己「*写*」到的位置，从服务器使用 slave_repl_offset 来记录自己「*读*」到的位置。

在主服务器进行命令传播时，不仅会将写命令发送给从服务器，还会将写命令写入到 repl_backlog_buffer 缓冲区里，因此 这个缓冲区里会保存着最近传播的写命令。

网络断开后，当从服务器重新连上主服务器时，从服务器会通过 psync 命令将自己的复制偏移量 slave_repl_offset 发送给主服务器，主服务器根据自己的 master_repl_offset 和 slave_repl_offset 之间的差距，然后来决定对从服务器执行哪种同步操作：





##### 哨兵模式：

在 Redis 的主从架构中，由于主从模式是读写分离的，如果主节点（master）挂了，那么将没有主节点来服务客户端的写操作请求，也没有主节点给从节点（slave）进行数据同步了。

Redis 在 2.8 版本以后提供的**哨兵（Sentinel）机制**，它的作用是实现**主从节点故障转移**。它会监测主节点是否存活，如果发现主节点挂了，它就会选举一个从节点切换为主节点，并且把新主节点的相关信息通知给从节点和客户端。

它相当于是“观察者节点”，观察的对象是主从节点。

哨兵节点主要负责三件事情：**监控、选主、通知**。



1. 第一步：**(选新主节点)**在已下线主节点（旧主节点）属下的所有「从节点」里面，挑选出一个从节点，并将其转换为主节点。
2. 第二步：**(让其他从节点认新主子)**让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」；
3. 第三步：**(把新主节点信息告诉客户端)**将新主节点的 IP 地址和信息，通过「发布者/订阅者机制」通知给客户端；
4. 第四步：**(把之前死掉的主节点，归到新主子的从节点下)**继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点；







- **哨兵节点是如何监控节点的？又是如何判断主节点是否真的故障了？**

哨兵会每隔 1 秒给所有主从节点发送 PING 命令，当主从节点收到 PING 命令后，会发送一个响应命令给哨兵，这样就可以判断它们是否在正常运行。

如果主节点或者从节点没有在规定的时间内响应哨兵的 PING 命令，哨兵就会将它们标记为「**主观下线**」

之所以针对「主节点」设计「主观下线」和「客观下线」两个状态，是因为有可能「主节点」其实并没有故障，可能只是因为主节点的系统压力比较大或者网络发送了拥塞，导致主节点没有在规定时间内响应哨兵的 PING 命令。

所以，为了减少误判的情况，哨兵在部署的时候不会只部署一个节点，而是用多个节点部署成**哨兵集群**（*最少需要三台机器来部署哨兵集群*），**通过多个哨兵节点一起判断，就可以就可以避免单个哨兵因为自身网络状况不好，而误判主节点下线的情况**。

当一个哨兵判断主节点为「主观下线」后，就会向其他哨兵发起命令，其他哨兵收到这个命令后，就会根据自身和主节点的网络状况，做出赞成投票或者拒绝投票的响应。

![img](https://img-blog.csdnimg.cn/13e4361407ba46979e802eaa654dcf67.png)

当这个哨兵的赞同票数达到哨兵配置文件中的 quorum 配置项设定的值后，这时主节点就会被该哨兵标记为「客观下线」。



- **根据什么规则选择一个从节点切换为主节点**？

先过滤掉网络状况不好的从节点

接下来要对所有从节点进行三轮考察：**优先级、复制进度、ID 号**。在进行每一轮考察的时候，哪个从节点优先胜出，就选择其作为新主节点。



- 第一轮考察：哨兵首先会根据从节点的优先级来进行排序，优先级越小排名越靠前，
- 第二轮考察：如果优先级相同，则查看复制的下标，哪个从「主节点」接收的复制数据多，哪个就靠前。
- 第三轮考察：如果优先级和下标都相同，就选择从节点 ID 较小的那个



- **怎么把新主节点的相关信息通知给从节点和客户端呢**？

发给从节点：这一动作可以通过向「从节点」发送 `SLAVEOF` 命令来实现。

发给客户端：主要**通过 Redis 的发布者/订阅者机制来实现**的。每个哨兵节点提供发布者/订阅者机制，客户端可以从哨兵订阅消息。







### 11乐观锁与悲观锁

------

悲观锁：每次读写数据的时候，都认为数据被修改，所以都会上锁。（互斥锁为例mutex）

乐观锁：每次读写数据的时候，都认为数据没有被修改，所以会上锁。（可以使用**版本号机制，CAS**）

### 12 redis 五种数据结构是哪五种，那些操作是O(0)的？

------

string,
list,
sorted set
set
hash(map套map)



### 13	什么时候应该用Redis？

------

Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此**读写速度非常快**，

常用于

**1缓存，**

**2消息队列、**

**3分布式锁等场景**

除此之外，Redis 还支持**事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布/订阅模式，内存淘汰机制、过期删除机制**等等。



### 14	redis的有序集合(Zset)底层实现是什么？如果让你实现，你会怎么实现？

------

Zset 类型的底层数据结构是由**压缩列表或跳表**实现的



### 15	redis失效时应该怎么处理，如果让你设计你方案，你会怎么设计？

------

应对三种主要失效的解决办法

1.缓存雪崩

解决问题：1、让热点数据不失效  2、将热点数据分时段失效

2.缓存击穿

解决方案：1、延长热点数据的有效时间   2、连接请求访问数据库的时候，进行上锁。

3.缓存穿透

解决方案：可以在缓存中设置键值对，前面是key，后null，类似于map<key, null>,这样在缓存中进行查询的时候，就会直接返回空，就不会在底层数据库进行查询。





### 16	Redis的几种淘汰策略？

------

当 Redis 达到最大内存限制时，Redis会确切地使用配置好的最大内存策略指令来执行。相关策略如下：

1.noeviction（默认策略）： 不会删除任何数据，拒绝所有写入操作并返回客户端错误消息（error）OOM command not allowed when used memory，此时 Redis 只响应删和读操作；

2.allkeys-lru： 从所有 key 中使用 LRU 算法进行淘汰（LRU 算法：最近最少使用算法）；

3.allkeys-lfu： 从所有 key 中使用 LFU 算法进行淘汰（LFU 算法：最不常用算法，根据使用频率计算，4.0 版本新增）；

4.volatile-lru： 从设置了过期时间的 key 中使用 LRU 算法进行淘汰；

5.volatile-lfu： 从设置了过期时间的 key 中使用 LFU 算法进行淘汰；

6.allkeys-random： 从所有 key 中随机淘汰数据；

7.volatile-random： 从设置了过期时间的 key 中随机淘汰数据；

8.volatile-ttl： 在设置了过期时间的key中，淘汰过期时间剩余最短的。

### 17.Redis五种数据结构的底层实现原理

------

**1.string**

**SDS（简单动态字符串）**SDS 相比于 C 的原生字符串：

- **SDS 不仅可以保存文本数据，还可以保存二进制数据**。因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。
- **SDS 获取字符串长度的时间复杂度是 O(1)**。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1)。
- **Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出**。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。

**2.list**

**双向链表或压缩列表**(在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表。)

- 如果列表的元素个数小于 512 个（默认值，可由 list-max-ziplist-entries 配置），列表每个元素的值都小于 64 字节（默认值，可由 list-max-ziplist-value 配置），Redis 会使用**压缩列表**作为 List 类型的底层数据结构；
- 如果列表的元素不满足上面的条件，Redis 会使用**双向链表**作为 List 类型的底层数据结构；

**3.Hash**

**压缩列表或哈希表**(在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 **listpack** 数据结构来实现了。)

- 如果哈希类型元素个数小于 512 个（默认值，可由 hash-max-ziplist-entries 配置），所有值小于 64 字节（默认值，可由 hash-max-ziplist-value 配置）的话，Redis 会使用**压缩列表**作为 Hash 类型的底层数据结构；
- 如果哈希类型元素不满足上面条件，Redis 会使用**哈希表**作为 Hash 类型的底层数据结构。

**4.Set**

**哈希表或整数集合**

- 如果集合中的元素都是整数且元素个数小于 512 （默认值，set-maxintset-entries配置）个，Redis 会使用**整数集合**作为 Set 类型的底层数据结构；
- 如果集合中的元素不满足上面条件，则 Redis 使用**哈希表**作为 Set 类型的底层数据结构

**5.ZSet**

**压缩列表或跳表**(在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。)

- 如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用**压缩列表**作为 Zset 类型的底层数据结构；
- 如果有序集合的元素不满足上面的条件，Redis 会使用**跳表**作为 Zset 类型的底层数据结构；

### 18	 Redis常见数据结构以及使用场景分别是什么？

------

- String 类型的应用场景：**缓存对象**、常规计数、分布式锁、共享 session 信息等。
- List 类型的应用场景：**消息队列**（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。
- Hash 类型：**缓存对象**、购物车等。
- Set 类型：**聚合计算（并集、交集、差集）**场景，比如点赞、共同关注、抽奖活动等。
- Zset 类型：**排序场景**，比如排行榜、电话和姓名排序等。



### 19	Redis持久化机制可以说一说吗？

------

将内存中的数据备份到磁盘。好处：断点重启之后，数据不会丢失

RDB持久化：将当前数据保存到硬盘（原理是将Reids在内存中的数据库记录**定时dump**到磁盘上的RDB持久化）。**默认的持久化方式**

AOF持久化：将每次执行的**写命令**保存到硬盘（原理是将Reids的操作日志以**追加的方式**写入文件，类似于MySQL的binlog），**主流的持久化方式**。





### 20	了解Redis的线程模型吗？可以大致说说吗？

------



**Redis 单线程指的是「接收客户端请求->解析请求 ->进行数据读写等操作->发送数据给客户端」这个过程是由一个线程（主线程）来完成的**，这也是我们常说 Redis 是单线程的原因。

但是，**Redis 程序并不是单线程的**，Redis 在启动的时候，是会**启动后台线程**（BIO）

- **Redis 在 2.6 版本**，会启动 2 个后台线程，分别处理关闭文件、AOF 刷盘这两个任务；
- **Redis 在 4.0 版本之后**，新增了一个新的后台线程，用来异步释放 Redis 内存，也就是 lazyfree 线程。

Redis 为「关闭文件、AOF 刷盘、释放内存」这些任务创建单独的线程来处理，是因为这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生阻塞，这样就无法处理后续的请求了。

后台线程相当于一个消费者，生产者把耗时任务丢到任务队列中，消费者（BIO）不停轮询这个队列，拿出任务就去执行对应的方法即可。



![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.drawio.png)



官方使用基准测试的结果是，**单线程的 Redis 吞吐量可以达到 10W/每秒**

之所以 **Redis 采用单线程（网络 I/O 和执行命令）那么快**，有如下几个原因：

- Redis 的大部分操作**都在内存中完成**，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；
- Redis 采用单线程模型可以**避免了多线程之间的竞争**，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。
- Redis 采用了 **I/O 多路复用机制**处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。

**Redis 6.0 之后为什么引入了多线程？**

**这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I/O 的处理上**。所以为了提高网络 I/O 的并行度，Redis 6.0 对于网络 I/O 采用多线程来处理。**但是对于命令的执行，Redis 仍然使用单线程来处理**

### 21	C++中的Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存？

------

缓存分为本地缓存和分布式缓存

1.Redis 可以用几十 G 内存来做缓存，Map 不行

2.Redis 的缓存可以持久化，Map 是内存对象，程序一重启数据就没了

3.Redis 可以实现分布式的缓存，Map 只能存在创建它的程序里

4.Redis 可以实现分布式的缓存，Map 只能存在创建它的程序里

5.Redis 可以处理每秒百万级的并发，是专业的缓存服务，Map 只是一个普通的对象

6.Redis 缓存有过期机制，Map 本身无此功能

### 22	Redis的五种数据结构、持久化方式

------

已答

### 23	Redis是如何实现快速查询的

------

Redis 中的查询速度为什么那么快呢？

1、因为它是内存数据库；

2、归功于它的数据结构；

3、Redis 中是单线程；

4、Redis 中使用了[多路复用](https://so.csdn.net/so/search?q=多路复用&spm=1001.2101.3001.7020)。

[(13条消息) 都知道Redis中的查询速度很快，那么Redis 如何保证高效的查询效率？_redis大数据量的查找效率_卡卡的Java架构笔记的博客-CSDN博客](https://blog.csdn.net/duan18888/article/details/124798492?ops_request_misc=&request_id=&biz_id=102&utm_term=Redis是如何实现快速查询的&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-124798492.142)





### 24	 数据可不可以不加锁实现数据传输？

------

​		::参考redis中的乐观锁机制，就用版本号方式或cas机制

