

## 9.C++基础知识类和对象

### 1 new和malloc的区别

------

new是安全的，malloc是不安全的。

new是c++运算符，malloc是c/c++标准库函数。

new自动计算要分配的大小，malloc要手工计算。

new返回的是具体类型指针，malloc是void类型指针。

构造函数调用：使用new关键字动态分配内存时，会自动调用对象的构造函数。而使用malloc函数则不会调用构造函数，需要手动调用。

### 2 new为什么是安全的

------

new是安全的，因为它将动态内存分配和对象的初始化结合在一起

new返回的指针类型严格与对象匹配，而不是void。

### 2.5new的工作原理

当使用new操作符创建对象时，系统会按照以下步骤进行内存分配和对象构造：

1. 查找需要分配内存的类型，确定所需的内存空间大小。
2. 在堆上分配对应大小的内存空间。
3. 如果需要，调用该类型的构造函数对对象进行初始化。
4. 返回指向新分配内存空间的指针。

在具体实现时，new操作符会调用operator new函数来完成内存分配，然后调用该类型的构造函数进行初始化，并返回指向新分配内存空间的指针。而operator new函数则是一个全局函数，可以通过重载来自定义内存分配方式。

举个例子， 如果我们使用new操作符创建一个int类型的对象，其工作原理如下：

```cpp
int* ptr = new int;
```

1. 系统会查找int类型所需的内存空间大小（通常为4个字节）。
2. 在堆上分配4个字节大小的内存空间。
3. 调用int类型的构造函数进行初始化（int类型的构造函数为空，不需要进行初始化）。
4. 返回一个指向新分配内存空间的指针，即ptr指针。

最后，使用完了new创建的对象，需要使用delete操作符将其释放，否则会导致内存泄漏。



### 3 	野指针和悬空指针

------

野指针就是没有初始化的指针

悬空指针就是指针最初指向的原始内存被释放掉了(智能指针的本意就是释放掉悬空指针)





### 4	有哪些智能指针

------

shared_ptr:共享所有权智能指针，强引用的智能指针

unique_ptr:独享所有权智能指针

weak_ptr:弱引用的智能指针



### 5 shared_ptr实现原理

------

引用计数法，每多一个智能指针指向对象，引用+1，而析构则相反，当引用计数为0时，则保存的指针被删除。



### 6 怎么实现一个简易版的unique_ptr

------

禁用赋值函数，让拷贝和构造函数都=delete

调用析构函数的时候，释放掉托管的对象资源



unique_ptr是C++11中的一个智能指针，用来管理动态分配的对象，确保在离开作用域时自动释放资源以避免内存泄漏。一个简易版的unique_ptr可以按照以下步骤实现：

1. 定义一个模板类，模板参数为需要管理的对象类型。
2. 定义一个指向该类型的指针成员变量，用来管理动态分配的对象。
3. 实现默认构造函数、移动构造函数和析构函数。
4. 重载*和->操作符，使得unique_ptr可以像普通指针一样操作被管理的对象。
5. 定义release函数，用来释放对被管理对象的控制权并返回指向该对象的指针。
6. 定义reset函数，用来释放已有的对象并接管新的对象。
7. 禁用拷贝构造函数和赋值运算符，确保unique_ptr对象的独占性。

下面是一个简单的unique_ptr实现示例：

```cpp
template<typename T>
class unique_ptr {
public:
    unique_ptr() : ptr_(nullptr) {}
    unique_ptr(T* ptr) : ptr_(ptr) {}
    unique_ptr(unique_ptr&& other) : ptr_(other.ptr_) { other.ptr_ = nullptr; }
    ~unique_ptr() { delete ptr_; }
    
    T* operator->() { return ptr_; }
    T& operator*() { return *ptr_; }
    
    T* release() {
        T* ptr = ptr_;
        ptr_ = nullptr;
        return ptr;
    }

    void reset(T* ptr) {
        T* old = ptr_;
        ptr_ = ptr;
        delete old;
    }

    // 禁用拷贝构造函数和赋值运算符
    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;

private:
    T* ptr_;
};
```

使用示例：

```cpp
int main() {
    unique_ptr<int> p1(new int(42));
    std::cout << *p1 << std::endl;  // 输出42

    unique_ptr<int> p2 = std::move(p1);
    std::cout << *p2 << std::endl;  // 输出42
    std::cout << (p1 == nullptr) << std::endl; // 输出1，p1已经释放了被管理的对象

    p2.reset(new int(24));
    std::cout << *p2 << std::endl;  // 输出24

    int* ptr = p2.release();
    std::cout << *ptr << std::endl; // 输出24
    delete ptr;
}
```

需要注意的是，这只是一个简单的实现，没有考虑到多线程和异常安全等问题，实际应用中需要更完善的实现。



### 7 纯虚函数能不能创建实例

------

不能，因为纯虚函数是抽象类

抽象类有两种：

①：纯虚函数，纯虚函数没有实际的实现，必须在派生类中实现。纯虚函数抽象类不能被实例化，只能作为基类使用。

②：定义了protected型的构造函数

### 8 右值引用的作用

------

右值引用是C++11中新增的新特性，它的作用主要包括：

1. **完美转发**：**右值引用可以将一个右值**（即将被销毁的临时对象或者没有其他名称的对象）**绑定到一个右值引用上**，**然后将该右值引用传递给另一个函数**。这样可以避免创建临时对象或者拷贝大量数据，提高程序的性能。
2. **移动语义**：**右值引用可以实现移动语义，即将一个右值引用绑定到一个临时对象上，并且这个临时对象的资源可以被“窃取”，然后转移到另一个对象上，避免不必要的内存拷贝和分配，提高程序的效率**。
3. 容器优化：对于容器而言，移动操作是比拷贝操作更高效的，因为移动操作不需要进行内存的分配和拷贝，可以直接将资源交给另一个对象，而这正是右值引用的优势所在。
4. 实现可变对象：使用可变右值引用可以使得一个对象既可以作为左值被修改，又可以作为右值被使用，从而实现更加灵活的对象使用方式。

总之，右值引用可以提高程序的性能和效率，实现更加高效的对象传递和管理方式，使得程序编写变得更加灵活和高效。

### 9 深拷贝和浅拷贝

------

浅拷贝只会拷贝一个指针，并没有新开辟一块空间，拷贝的指针和原来的指针指向同一块地址

深拷贝不仅拷贝值，还会开辟出一块空间用来存放这个值。



### 10 引用使用上的注意事项

------

**1 引用在定义的时候需要初始化，一旦绑定了一个变量，就不能再绑定到其他变量了**

2 类作为对象进行参数传递的时候，要用引用

3 对栈空间大小比较敏感（如递归）的时候，最好用引用



4 不要轻易返回一个堆空间变量的引用，容易发生内存泄漏

5 需要返回函数内部变量的内存的时候，用指针。



### 11sizeof和strlen的区别

------

**sizeof是运算符**，

**strlen是库函数**

sizeof是在编译时得到的

sizeof的参数可以是任意的数据类型，strlen的参数必须是字符指针，且结尾是'\0'的字符串

sizeof不能用来得到动态分配存储空间的大小

| sizeof               | strlen                                         |
| -------------------- | ---------------------------------------------- |
| 运算符               | 库函数                                         |
| 计算变量占用的字节数 | 计算字符串长度                                 |
| sizeof编译时计算     | strlen在运行时计算，需要遍历字符串才能确定长度 |

例如：

```cpp
char a[10] = "Hello";
cout << sizeof(a) << endl;  // 输出10
cout << strlen(a) << endl;  // 输出5
```

在这个示例中，sizeof(a)返回的是数组a占用的空间大小，即10个字节。而strlen(a)返回的是字符串a的长度，即5个字符。

### 12头文件多次调用的重定义有哪些方式避免？从代码层面来讲

------

头文件多次调用的重定义问题是C++编程中一个很常见的问题，主要表现为在一个源程序中多次 #include 同一个头文件时，同一个标识符或宏定义可能会被多次定义，从而导致编译错误。

为了避免头文件的重定义问题，可以采用以下几种方式：

1. 使用预处理指令 #ifndef 和 #define 以及 #endif：

```cpp
#ifndef HEADER_H
#define HEADER_H
// 头文件内容
#endif
```

这三个指令的作用是：如果这个头文件没有被定义过，就定义它，否则跳过。头文件的内容被包含在 #ifndef 和 #endif 之间。

1. 使用#pragma once 指令：

```cpp
#pragma once
// 头文件内容
```

\#pragma once 是一条编译指令，它可以保证一个头文件在一个文件中只被包含一次。虽然这种方法比 #ifndef 和 #define 短小精悍，但是不是所有的编译器都支持 #pragma once。

1. 使用编译选项 -include 或者 -isystem：

```bash
g++ -include header.h main.cpp -o main
g++ -isystem dir1 -isystem dir2 main.cpp -o main
```

-include 指令可以将指定的头文件在编译前预先包含进来，可以避免头文件重定义的问题。-isystem 选项可以告诉编译器搜索头文件的路径，在编译时会忽略系统头文件目录和 -I 选项定义的路径下的头文件，这样可以避免多个目录下的同名头文件冲突。

这些方法应该从代码层面来操作，尽可能减少头文件的依赖关系，将头文件设计得更为清晰和简洁，尽量避免在头文件中定义全局变量或函数，把这些定义放到 .cpp 文件中，并在头文件中声明即可。此外，还应该遵循良好的编程规范，尽可能减少使用宏定义和全局变量等易于生成重定义错误的语言特性。

### 13	using的用法

1 命名空间的使用

2 在子类中引用基类的成员

3 别名的指定



跟typedef的区别：

using可以给模板起别名



### 14二级指针是啥东西

------

指向指针的指







针

### 15简单说一下C语言中和C++中内存管理的区别

------

管理内存一般指程序员申请和释放堆空间内存，

在C中，我们使用malloc和free进行堆空间管理，这个空间一般是不会初始化的，除非是使用calloc等申请空间函数，C++中对内存管理的方式有很多，首先是堆空间的申请，

C++中常用new/delete组合进行堆空间申请，并且它是主动对申请空间进行了置0的初始化动作的，但是实际上，其底层也是使用malloc实现的；

其次C++中对栈空间管理经常采用RAII的方式，即智能指针进行栈空间管理

### 16说一下struct和class的区别

------

struct成员默认权限是public，class默认权限是private，实际class底层由struct实现

### 17说一下C++的特性

------

抽象、封装、继承、多态
抽象：是所有语言的特性，将对象抽象成代码实现
封装：C++理念，一切皆对象，将对象封装成class，提供属性和方法
继承：派生类通过：public申明基类对象，将基类成员吸收到派生类中等等等等
多态：使用虚函数的特性，通过底层的虚函数表，实现同样的方法在不同对象中的不同响应

### 18说一下多态的实现

------

多态的五步骤

第一步：创建基类，包含虚函数

第二步：创建派生类，派生类重写基类中的虚函数(覆盖)

第三步：创建派生类对象

第四步：基类的指针(引用)指向(绑定)到派生类对象

第五步:   使用基类指针(引用)调用虚函数





### 20说一下虚函数和虚继承同时发生时，加上数据成员的内存布局（这个百度的）

------

根据IDE而定，部分IDE编译时是将数据成员内存申请在虚函数表前，虚函数表后为虚基表，部分是虚函数表在最前，虚基表在中间，数据成员在后

对于含有数据成员的多继承类，其内存布局应该是：先放置基类中的数据成员，然后放置派生类中非虚基类的数据成员，接着是虚基指针和虚指针，最后是虚基类的数据成员和派生类中的虚函数表。这些数据根据对齐规则被放置在内存中相应的位置。

### 21一个空class占用内存大小

------

大小为1

### 22class内存大小要关注的问题

------

内存对齐：为了提高内存访问速度，编译器会将数据成员按照一定的规则进行内存对齐，这样可能会在数据成员之间填充一些空的字节，从而造成内存浪费

数据成员的大小

虚函数指针：如果类中包含虚函数，那么会在每个对象中引入一个指向虚函数表的指针，这个指针的大小由机器的字长决定，通常为 4 字节或 8 字节。如果该类还是其他类的派生类，那么会包含一个指向基类的指针，也会占用至少一个指针的大小。此外，





### 23简单讲一下智能指针

------

用于管理动态内存

RAII
auto_ptr，淘汰的，不用
unique_ptr，不可赋值和拷贝的指针
shared_ptr，解决unique_ptr不可复制的问题，采用COW的概念，使用引用计数的方式，将所有指向同样内存的对象连接到同一片空间，通过引用计数管理和释放空间
weak_ptr，解决shared_ptr存在的循环引用问题



### 24移动语义

------

右值引用（&&），左值引用（const&）、std::move、&&通过完美转发实现伪万能引用、const&是万能引用，将深拷贝换成浅拷贝，将内存的原指向断开，链接给新对象，减少拷贝次数，提升效率

### 25指针和引用的区别

------

引用实际是指针常量

指针：地址

引用：别名，引用本身不占内存空间

### 26解释一些指针常量和常量指针

------

int * const p=可以修改值，不可修改指向

const int * p=可以修改指向，不可以修改值

一个是不能修改值，一个是不能修改指向

### 27解释一下宏定义和inline的区别

------

宏定义和 inline 是 C++ 中用于定义函数的两种方式。

宏定义是一种**预处理器**功能，通过**预处理器将宏展开成对应的代码**。宏定义使用 #define 关键字来定义，例如 #define PI 3.14159。宏定义的优点是简单快速，但是缺点是可能引起符号冲突和类型不匹配的问题，而且没有作用域，可能引起意外的副作用。

inline 是一种**编译器的指示**，告诉编译器将函数体直接嵌入到调用代码中，而不是像普通函数一样生成函数调用的汇编代码。inline 函数在调用时会直接展开代码，具有执行速度快、省去函数调用开销的优点，但是也有可能增加代码的大小，并且过度使用 inline 可能会导致代码的可读性下降。



宏定义发生在**预编译**过程，简单的文本替换，不做语法检测
inline发生在**编译**过程，会检测语法，不用替换

### 28alloctor分配内存原理

------

大于128的直接malloc
小于128的用内存数组链表管理（详见alloctor课那里的讲解，非常详细）



### 29lambda表达式

------

？？？？？？





### 30值传递和引用传递

------

值传递是将实参的值完整地复制一份传递给函数

引用传递是将实参的地址传递给函数

### 31观察者模式

------

观察者模式是一种常用的软件设计模式，它定义了一种**一对多**的依赖关系，让多个观察者对象同时监听同一个主题对象，当**主题对象发生变化时，会通知观察者对象**，使它们得到及时更新。

观察者模式中包含的角色有：

1. 主题（Subject）：被观察的对象，维护了一个**观察者列表**，提供注册和删除观察者的方法，以及通知观察者的方法。
2. 观察者（Observer）：在主题发生变化时需要得到通知情况下的对象。
3. 具体主题（具体被观察者）（ConcreteSubject）：实现主题接口，维护状态，当状态改变时，**通知**所有的观察者。
4. 具体观察者（ConcreteObserver）：实现观察者接口，实现相应的方法，当接收到主题的通知时进行更新。

观察者模式的优点在于，主题和观察者之间是松耦合的，**主题并不需要了解具体的观察者，它只需要知道观察者实现了某个接口即可**。这样，当需要添加新的观察者时，只需要实现相应的接口即可，而不需要对主题进行修改。另外，**观察者模式还可以实现一种广义上的发布/订阅模式，不同的观察者可以订阅不同的主题，以实现精确的通知机制**。

但是，观察者模式也存在一些**缺点**，主要体现在以下方面：

1. 观察者过多时，通知的**开销会增加**，可能会导致性能问题。
2. 观察者和主题之间存在**循环依赖**时，容易出现内存泄漏。
3. 当观察者和主题之间存在复杂的交互时，可能导致系统难以维护

### 

### 33C++的强制类型转换

------

1C风格强制类型转换：(type)expression。这种方式是最原始的方式

2static_cast：用于基本数据类型之间、父子类之间的转换。

3dynamic_cast：用于父子类之间的转换，通常用于多态中的类型转换，可以将父类指针或引用转换为子类指针或引用

4reinterpret_cast：用于不同类型之间的转换，包括将指针类型和整型之间的转换。这种方式完全不考虑类型间的关系，只是将二进制数据按照所需的类型进行重新解释。这种方式风险较高，应尽量避免使用



### 34动态指针的判空

------

当动态分配的内存被释放后，指针变量会被自动置为NULL。因此，可以在使用动态指针前，先判断指针变量是否为NULL，

### 35C++ 11有什么新的特性

------

1. **自动类型推导(auto)**：
2. **智能指针**(unique_ptr, shared_ptr)：
3. **lambda表达式**：可以定义匿名函数，给算法和函数对象带来了更强的表现力。
4. **右值引用和移动语义**：提供了更有效的资源管理方式，可以减少内存拷贝和移动对象。
5. constexpr函数：可以在编译期计算，提高了程序性能。
6. 线程库：引入了C++11标准线程库，可以更方便地编写多线程程序。
7. 静态断言(static_assert)：可以在编译期进行断言，有助于程序的调试。
8. 列表初始化：引入了花括号初始化语句，可以方便地进行初始化。
9. **可变参数模板**：提供了一种处理可变形参数的方式，可以使代码更具有通用性。
10. 规范化的代码：C++11引入了更多的规范化的代码，可以让程序员更轻松地编写正确的代码。

### 36基类子类的构造析构函数顺序

------

当一个派生类（子类）被创建时，它的父类（基类）的构造函数会被首先调用，然后再调用派生类自己的构造函数。反过来，在派生类被销毁时，它的析构函数先被调用，随后是父类的析构函数。

### 37纯虚函数有什么特点，该怎么用

------

特殊的虚函数，它没有实现，只需要提供接口，这个类为抽象类，抽象类不能实例化对象。

抽象类只有被继承后，派生类才能实例化对象，同时派生类必须实现抽象类中的纯虚函数(覆盖).

### 38面向对象和面向过程的区别

------



| 面向对象                                     | 面向过程                           |
| -------------------------------------------- | ---------------------------------- |
| 通过对象之间的交互来完成任务                 | 面向过程则是将任务分解成一系列步骤 |
| 强调数据的抽象和封装                         | 关注解决问题的步骤和算法           |
| 封装，继承，多态，可复用性和扩展性，更加灵活 | 需要明确的算法和过程               |
| 代码的可读性和可维护性                       | 代码的执行效率和速度               |

### 39讲一下封装、继承、多态

------

封装、继承、多态是面向对象编程中的三大特性，它们分别是：

1. 封装：将数据和方法**封装成一个类**，并**对外提供一定的接口**，**隐藏内部实现细节**，**提高代码的可维护性、可重用性和安全性**。
2. 继承：通过继承机制，**实现代码的复用性**，减少代码的冗余和重复，**同时通过继承来实现类与类之间的关联与扩展**。使得子类具有父类的属性和方法，同时又可以在此基础上进行扩展
3. 多态：**多态是指同一种操作作用于不同对象时**，**可以产生不同的实现和结果**。多态性可以通过函数重载、运算符重载、虚函数等方式来实现。

这三种特性是面向对象编程的重要特点，下面分别进行详细解释：

1. 继承：继承是面向对象编程中实现复用性的一种机制，它可以。继承有单一继承和多重继承之分，单一继承是指一个类只能继承一个父类，而多重继承是指一个类可以同时继承多个父类。继承可以通过关键字extends（Java）和冒号（C++）来实现。



### 40 什么地方需要用到拷贝构造函数？

------

拷贝构造函数是在对象复制时被调用的构造函数，用于将一个对象的值复制到另一个对象中。下面是一些常见的需要用到拷贝构造函数的场景：

1. 对象作为函数参数传递：
2. 对象作为函数返回值：
3. 对象初始化：
4. 对象赋值：



### 41	virtual()=0 是什么意思？

------

纯虚函数

### 42public/priavate继承的关系

------

public继承和private继承是C++中常见的两种继承方式，它们之间的关系如下：

1. public继承：被继承的成员在派生类中的访问权限与基类中的访问权限保持一致或更为宽松，可以通过派生类对象或指针来访问基类中的公有成员和保护成员，但不能访问基类中的私有成员。这种继承方式在实现多态性和代码复用方面非常有用，因为它允许派生类对象被视为基类对象使用。
2. private继承：被继承的成员在派生类中的访问权限都变为了私有，无论基类中原来的访问权限是什么。这种继承方式主要用于实现代码复用，因为它可以将基类中的实现细节隐藏起来，同时也可以通过派生类提供接口来访问基类中需要使用的函数和数据。

可以总结为：

- public继承是一种"is-a"关系，派生类对象可以被视为基类对象使用。
- private继承是一种"has-a"关系，派生类对象包含了基类对象的实现，可以通过提供接口来访问基类中需要使用的函数和数据。

需要注意的是，使用继承时，**应该尽量避免使用public继承，因为它会破坏封装性**；而应该优先考虑使用private继承或组合（即"has-a"关系）。





### 44new和malloc哪个会调用构造函数？

------

1. new是C++关键字，malloc是C语言库函数。

构造函数是用来初始化对象的函数，如果需要在动态分配的内存中创建对象，就需要调用构造函数。new操作符会同时进行内存分配和对象构造，因此不需要手动调用构造函数。而malloc只会进行内存分配，并不会调用构造函数，因此需要手动调用构造函数进行对象初始化。

**在C++中，使用 new 关键字分配内存会调用类的构造函数，而使用 malloc() 函数分配内存则不会调用构造函数。这是因为 new 关键字是 C++ 中的运算符，它会在分配内存后调用类的构造函数，而 malloc() 函数则是 C 标准库中的一个函数，它只是简单地分配内存，并不会调用构造函数。**

### 45如果我有一块地址空间，我怎么在这个地址空间内调用构造函数？

------

可以使用placement new操作符。它是C++的一个特殊操作符，用于在指定的内存地址上调用构造函数

placement new 的语法如下：

```c++
new (地址) 类型(参数);
```

其中，地址是需要在其上进行构造的内存地址，类型是要构造的对象类型，参数是传递给构造函数的参数列表。例如：

```c++
char* mem = new char[sizeof(Example)]; // 申请内存
Example* example = new (mem) Example; // 在内存上调用Example的构造函数
```

这里首先使用 char* 类型的指针 mem 申请内存，然后使用 placement new 在 mem 指向的内存上调用Example的构造函数。需要注意的是，在使用 placement new 时一定要保证地址正确、内存足够，并且在使用完后手动调用析构函数进行对象释放。

### 46讲一下对于模板template

------

模板（template）是C++中的一个重要特性，它**允许在不知道具体数据类型或者数据结构的情况下**，**定义出通用的算法或数据类型**。模板主要分为函数模板和类模板两种，函数模板的定义形式为：

```cpp
template<class T> 返回类型 函数名(参数列表) {
    // 函数体
}
```

其中，`class T` 或者 `typename T` 表示模板参数类型，可以是任意类型，函数体中可以使用这个类型进行操作。在函数调用时，编译器会根据实际传入的参数类型自动推导出模板参数的类型。

类模板的定义形式为：

```cpp
template<typename T>
class 类名 {
public:
    // 成员函数
private:
    // 成员变量
};
```

其中，`typename T` 表示模板参数类型，可以是任意类型，类体中可以使用这个类型进行操作。在类实例化时，编译器会根据类模板定义中的模板参数类型，生成对应的具体类。例如，可以定义一个名为 `MyVector` 的类模板，用于定义一个向量容器，可以在实例化时指定元素类型。

除此之外，**C++中还支持函数模板和类模板的特化和偏特化（Partial Specialization），分别用于指定特定的模板参数类型情况下的实现方式**。在使用模板时，需要注意避免代码膨胀和编译错误等问题。

### 47 void*的大小是多少？

------

在不同的操作系统或编译器下，`void*` 的大小可能会有所不同。在大多数 32 位系统中，`void*` 的大小为 4 字节（32 位），而在大多数 64 位系统中，`void*` 的大小为 8 字节（64 位）。

### 48说说static的用法？

------

在 C++ 中，`static` 关键字有多个用法，下面分别进行介绍：

1. **静态变量**：在函数内部使用 `static` 关键字声明的变量为静态变量。静态变量的生命周期与程序的生命周期相同，其值在每次进入函数时不会被重新初始化，可以用于在函数调用之间保留值，也可以用于函数内部变量的共享，也可以用于对全局变量的封装。
2. **静态成员变量**：**在类中使用 `static` 关键字声明的变量为静态成员变量。静态成员变量属于类本身，而不是属于每个类的实例**，**它在程序运行期间只被分配一次内存**。可以通过类名加作用域运算符来访问静态成员变量，也可以通过对象名来访问静态成员变量。
3. **静态成员函数**：**在类中使用 `static` 关键字声明的函数为静态成员函数。静态成员函数属于类本身，而不是属于每个类的实例，在调用静态成员函数时不需要创建对象，可以直接使用类名来调用**。静态成员函数只能访问静态成员变量，不能访问非静态成员变量。
4. **文件作用域变量和函数：在全局范围内使用 `static` 关键字声明的变量和函数为文件作用域变量和函数，它们只在当前文件中可见，不会被其他文件访问。**这个用法主要是为了实现信息隐藏和封装。

总之，`static` 关键字在 C++ 中有多个用法，主要包括静态变量、静态成员变量、静态成员函数，以及文件作用域变量和函数。它们都具有信息隐藏和封装的作用，同时也可以用于程序中的一些特殊需求。



### 49继承：构造函数可不可以是虚函数

------

构造函数不能是虚函数，因为在对象被创建时，虚函数表还没有被填充。在调用构造函数时，对象尚未建立，因此无法确定其虚函数表指针的值，也就无法确定调用哪个虚函数。

此外，**构造函数是用来初始化对象的，而虚函数是用于实现多态性的。虚函数在调用时需要通过对象的指针或引用进行动态绑定，而构造函数在对象还未建立之前就已经执行了，因此无法进行动态绑定。**





### 51delete与delete[]

------

`delete`操作符用于**释放单个对象所占用的内存**，其语法为：

```cpp
delete pointer;
```

其中，`pointer`是指向使用`new`操作符申请的**单个对象的指针**。

`delete[]`操作符则用于释放**数组对象所占用的内存**，其语法为：

```cpp
delete[] pointer;
```

其中，`pointer`是指向使用`new[]`操作符申请的**数组对象的指针。**

1. 在释放指针所指向的内存之前，应该确保指针的值不为NULL，否则会导致运行时错误。
2. 删除指针所指向的内存后，应该将指针设置为NULL，以避免产生野指针的问题







### 53.虚函数，虚继承以及原理

------

虚函数（virtual function）是C++中的一个概念，它允许**在基类和派生类之间实现多态性**（polymorphism）。**一个虚函数是在基类中定义的，但可以在派生类中重新定义**。**当调用一个虚函数时，实际调用的是派生类中重载的函数，而不是基类中的函数**。

虚继承（virtual inheritance）是用于**解决C++中的菱形继承**问题的一种技术。**菱形继承指的是当一个派生类从两个不同的基类继承而来，而这两个基类又继承自同一个基类时，会出现二义性的问题。为了解决这个问题，可以使用虚继承，使得从基类继承而来的成员在派生类中只保留一份。**

虚函数和虚继承的**原理**都是通过

虚表（virtual table）和虚指针（virtual pointer）来实现。

每个类（包括基类和派生类）都有一个虚表，其中包含了该类的虚函数的地址。

当调用一个虚函数时，**实际执行**的是**虚表中存储**的**地址对应的函数**。

而**虚指针则指向该类的虚表**，它的作用是在运行时动态查找该类对应的虚表，从而正确地调用虚函数。在虚继承中，由于多个派生类都可能继承同一个虚基类，因此需要使用虚指针来区分这些虚基类的不同实例。

总之，虚函数和虚继承是C++中实现多态性和解决菱形继承问题的重要机制，它们的原理都基于虚表和虚指针的概念。











### 54.malloc底层（不同编译器不同）：怎么传入一个长度，传出一个地址，最后free时准确free（多申请4个字节，存储相关信息）

------

`malloc`是C语言中动态内存分配函数，用于在堆内存中动态地分配一段指定大小的内存空间。其实现原理是调用操作系统的分配内存函数来申请一块内存空间，并返回一个指向该内存块首地址的指针。

不同编译器的实现可能会有所不同，但通常会在申请的内存块前面多申请一些空间，用于存储使用该内存块的相关信息，如内存块的大小、是否已经被分配等信息。这些额外存储的信息被称为"header"或"prologue"。具体实现方式会因编译器而异。

在使用`malloc`时，需要传入一个整数作为参数，表示需要申请的内存块的大小。`malloc`会尝试找到一块足够大的内存空间来满足请求，并返回该内存块的首地址。如果无法满足请求，则返回NULL。

使用完`malloc`申请的内存空间后，需要使用`free`函数释放该内存块。`free`函数需要传入内存块的首地址作为参数，通过该地址找到内存块头部的相关信息，并正确释放内存块。因此，在实现`malloc`底层时，需要确保头部信息能够被准确的找到和读取，以便在释放内存块时正确的操作。

### 55.虚拟内存，虚拟地址

------

虚拟内存和虚拟地址是**操作系统中重要的概念。**

**在虚拟内存中，每个进程都有其自己的虚拟地址空间，而这个虚拟地址空间可以超出物理内存的大小**。

虚拟内存管理器会将进程中未使用的数据从物理内存中移除，存储到磁盘上，而**进程只会看到自己的虚拟地址，而不知道其实际在物理内存中的位置。**

**虚拟地址**是一种**在进程中使用的地址**，它可以在进程地址空间中任意分配。在使用虚拟地址时，操作系统会将**虚拟地址映射到物理地址，从而实现内存的访问**。

### 56公有继承和私有继承的应用场景？

公有继承适用于以下场景：

1. 实现“is-a”关系：当一个派生类可以被看作是一个基类的特殊类型时，使用公有继承。例如，**学生可以被看作是一个人，因此可以使用公有继承来实现这种关系。**
2. 代码重用：**当多个类之间存在相同的代码或数据成员时**，使用公有继承可以避免代码的重复定义。派生类可以继承基类的公有成员和保护成员，**从而避免了代码的重复编写。**

私有继承适用于以下场景：

1. 实现“has-a”关系：当一个派生类包含一个基类对象时，使用私有继承。例如，**汽车可以包含一个发动机对象，因此可以使用私有继承来实现这种关系。**
2. 隐藏实现细节：**当需要隐藏基类的实现细节时**，使用私有继承可以有效地实现这一目的。私有继承会隐藏基类的公有成员和保护成员，从而使得派生类只能通过自己的公有接口来访问基类的成员。



### 57const关键字的使用（修饰返回值/参数/函数）

const关键字可以用来修饰**函数参数**、**函数返回值**以及**函数本身。**

1. 修饰函数参数：const关键字用来指定函数参数是只读的，即在函数内部不能修改参数的值，这样可以确保函数不会无意间修改函数外部的变量或对象。

```c++
void func(const int x) {
    // x是只读的，不能修改
    // ...
}
```

1. 修饰函数返回值：const关键字用来指定函数返回值是只读的，即返回值不能被修改。

```c++
const int func() {
    int x = 10;
    return x;
}
```

1. 修饰函数本身：const关键字用来指定成员函数是只读的，即在函数内部不能修改对象的状态或调用非const成员函数。

```c++
class MyClass {
public:
    int getValue() const {
        // 不能修改成员变量mValue的值
        return mValue;
    }
private:
    int mValue;
};
```

### 58重载和覆盖的使用？

重载(Overloading)和覆盖(Overriding)是C++中的两个重要概念，它们分别用于解决函数和类中的同名问题。

重载指的是在**同一个作用域中，定义了多个具有相同名称但参数类型和数量不同的函数。重载函数可以根据不同的参数类型来调用不同的函数**。例如，以下例子中的函数`print`就是一个重载函数：

```c++
void print(int num) {
    cout << "The integer is : " << num << endl;
}

void print(double num) {
    cout << "The double is : " << num << endl;
}
```

在调用`print`函数时，**可以根据传入参数的类型，自动调用对应的函数**，例如：

```c++
print(5);  // 调用第一个print函数，输出：The integer is : 5
print(3.14); // 调用第二个print函数，输出：The double is : 3.14
```

覆盖指的是在**派生类中重新定义父类中已有的虚函数，使得派生类中的该函数可以替代父类中的该函数。**例如，以下例子中的类`Shape`和`Rectangle`就是一个覆盖例子：

```c++
class Shape {
public:
    virtual void draw() {
        cout << "Drawing a Shape." << endl;
    }
};

class Rectangle : public Shape {
public:
    void draw() {
        cout << "Drawing a Rectangle." << endl;
    }
};
```

在创建一个`Rectangle`对象并调用`draw`函数时，由于`Rectangle`类重新定义了`Shape`类中的`draw`函数，因此会自动调用`Rectangle`类中的`draw`函数：

```c++
Shape* shape = new Rectangle;
shape->draw(); // 输出：Drawing a Rectangle.
```

总之，重载和覆盖都是C++中非常重要且有用的概念，它们可以用于解决函数和类中的同名问题。重载适用于解决参数类型和数量不同的函数的命名问题，而覆盖适用于解决继承中父类和子类中函数重名的问题。

### 59inline函数的使用？缺点是什么？

inline函数是C++中一种特殊的函数，**其将函数体直接嵌入到调用语句中，以减少函数调用带来的开销，提高程序的运行效率**。

inline函数的使用可以通过在函数声明处使用inline关键字来实现，例如：

```
inline int sum(int a, int b) {
    return a + b;
}
```

使用inline函数的优点是可以提高程序的运行效率，特别是在频繁调用的函数中。但是，inline函数的**缺点**也是显而易见的：

1. **编译器可能会忽略inline关键字，不把函数体嵌入到调用语句中，此时inline函数就退化成了普通函数。**
2. i**nline函数的函数体会被复制到每个调用处，增加了程序的代码量和内存占用**。
3. **在文件中多次使用inline函数，会增加目标代码的大小和加载时间，造成程序运行速度的下降**。



### 60shared_ptr使用的注意事项？有没有使用过weak_ptr？

1. shared_ptr使用的注意事项：

（1）shared_ptr的引用计数机制**存在循环引用**的问题，即A对象和B对象互相持有对方的shared_ptr，导致引用计数不为0而无法释放内存。解决办法是使用weak_ptr来打破循环引用。

（2）不能用一个原始指针初始化多个shared_ptr，否则会**导致重复释放内存**，造成程序崩溃。

（3）不能用一个原始指针初始化一个shared_ptr，同时又把**该指针释放掉，否则会导致智能指针指向非法内存**。

1. weak_ptr的使用：

**weak_ptr也是一种智能指针，它可以解决shared_ptr的循环引用问题。**

**weak_ptr指向的对象并不拥有引用计数，也不会增加引用计数，因此不会造成循环引用。同时，weak_ptr还提供了lock()函数，可以将其转化为一个shared_ptr，以便访问对象。**

使用weak_ptr时需要注意以下几点：

（1）不能直接用原始指针初始化一个weak_ptr，必须用一个shared_ptr初始化。

（2）不能通过weak_ptr直接访问对象，必须使用lock()函数将其转化为一个shared_ptr后才能访问。

（3）由于weak_ptr指向的对象可能已经被释放，因此在访问前需要判断转化后的shared_ptr是否为空指针。

1. 

### 61迭代器失效问题

迭代器失效问题是指在使用迭代器遍历容器元素的过程中，执行了某些操作后，原先的迭代器可能会失效，无法继续使用。

这种问题通常出现在以下场景中：

1. 在使用迭代器遍历容器元素的过程中，执行了插入、删除等修改容器元素的操作。这些操作可能会导致容器内部元素的内存重新分配，导致原先的迭代器失效。

解决办法：避免在迭代器遍历容器元素的过程中，执行**插入、删除**等修改容器元素的操作。**如果必须执行这些操作**，**可以使用相应的容器操作函数来获取新的迭代器**。

1. 在使用迭代器遍历容器元素的过程中，执行了赋值、复制等操作，导致原先的容器元素发生变化，从而使原先的迭代器失效。

解决办法：避免在迭代器遍历容器元素的过程中，执行**赋值、复制**等操作。如果必须执行这些操作，可以使用相应的容器操作函数来获取新的迭代器。

总之，为了避免迭代器失效问题，1 **我们需要避免在迭代器遍历容器元素的过程中**，执行修改容器元素、赋值、复制等操作，2 **或者使用相应的容器操作函数来获取新的迭代器。**

### 62假设有一个指针，如何做到多次使用，一次释放？（reset操作）

假设有一个指针p，**可以通过智能指针shared_ptr的reset()成员函数来实现多次使用一次释放的操作**。

shared_ptr的reset()函数可以将其拥有的指针释放，然后将智能指针重新指向一个新的指针或者置为空指针，这样就能够多次使用一个指针，即每次使用完指针后，调用reset()函数将其释放，然后再次使用时重新分配内存并指向新的指针。

例如，可以使用如下代码实现多次使用一次释放功能：

```
#include <memory>

int main() {
    std::shared_ptr<int> p;
    for (int i = 0; i < 10; ++i) {
        p.reset(new int{i}); // 释放之前的指针，并分配新的内存空间
        // 使用p指向的内存
        // ...
    }
    return 0;
}
```

在每次循环开始前，使用reset()函数释放之前的指针，在本例中即释放之前分配的int类型内存空间，并分配新的内存空间重新指向。

需要注意的是，**调用reset()函数时，智能指针所指的内存应该是不再被使用的**，否则可能会造成内存泄漏或者程序崩溃的情况。

可以使用std::shared_ptr来实现指针的多次使用和一次释放，具体实现如下：

```c++
#include <memory>

int* p = new int(10); // 创建一个指向int类型的动态内存
std::shared_ptr<int> ptr(p); // 将动态内存交给shared_ptr管理

// 使用ptr指向的动态内存
std::cout << *ptr << std::endl;

// 重置ptr指向的动态内存
ptr.reset(new int(20));

// 再次使用ptr指向的动态内存
std::cout << *ptr << std::endl;

// 在ptr被销毁时，会自动释放指向的动态内存，无需手动释放
```

在这个例子中，我们创建了一个指向int类型的动态内存，并将其交给std::shared_ptr ptr管理。可以多次使用ptr指向的动态内存，每次使用前需要通过reset函数将其重置为新的动态内存，从而实现一次释放多次使用的效果。当ptr被销毁时，会自动释放指向的动态内存，无需手动释放。

### 64写时拷贝

写时拷贝（Copy on Write，简称COW）是一种内存优化技术，**可以在多个对象共享同一个资源时，避免不必要的内存拷贝和资源浪费**。

具体实现方法是，在多个对象共享同一资源时，每个对象都持有一个指向该资源的指针，并且共享相同的**计数器**。**当某个对象对该资源进行修改时，再进行内存拷贝和资源分配，以确保修改只影响到自己的拷贝，而不会影响到其他对象的拷贝。**

写时拷贝可以提高程序的性能和内存使用效率，特别是在涉及大量数据的情况下。但是，写时拷贝也有一些**缺点**，例如：

1. 内存分配和释放需要消耗额外的时间和资源。
2. 写时拷贝可能会影响程序的并发性和**线程安全性**，需要采取额外的措施来避免竞态条件和数据不一致的问题。
3. **写时拷贝不适合频繁进行修改操作**，因为每次修改都需要进行内存拷贝和资源分配，会导致程序性能下降。

在实际开发中，需要根据具体的应用场景和需求，来选择合适的内存管理策略和算法，以确保程序的性能和稳定性。



### 66malloc之后怎么判断是否出错

在使用malloc分配内存时，可以通过以下两种方式来判断是否分配成功：

1. **判断返回值是否为NULL**：malloc在分配内存失败时会返回NULL，因此可以通过判断返回值是否为NULL来判断是否分配成功。

```c
int* ptr = (int*)malloc(sizeof(int));
if (ptr == NULL) {
    printf("Memory allocation failed.\n");
    exit(1);
}
```

1. **使用断言**：可以使用**assert宏**来判断malloc是否分配成功。assert宏的作用是在程序运行时检测特定条件的正确性。如果断言的条件不成立，assert将输出一条错误信息并终止程序。因此，使用assert可以在出现错误时及时终止程序，避免继续执行可能会出现的错误代码。

```c
#include <assert.h>

int* ptr = (int*)malloc(sizeof(int));
assert(ptr != NULL);
```

无论是哪种方式，如果分配内存失败，程序都应该及时处理错误。最常见的处理方式是输出错误信息并终止程序。

另外，当使用malloc分配内存后，在使用完后一定要记得调用free函数来释放内存，否则会导致内存泄漏。

### 67C怎么调用C++，c++怎么调用C

**C调用C++**：

1. 如果C++代码只有一个main函数，可以将C++代码保存为.cpp文件，然后使用C语言的编译器来编译它。
2. 如果C++代码中有多个函数或类，可以将其封装为一个DLL或者静态库，然后在C代码中调用DLL或者静态库中的函数。

调用C++中的函数需要使用**extern "C"来告诉C++编译器将其导出为C函数**，例如：

C++代码：

```
extern "C" {
    void MyFunction() {
        // code here
    }
}
```

C代码：

```
extern void MyFunction(); // 声明C++函数

int main() {
    MyFunction(); // 调用C++函数
    return 0;
}
```

**C++调用C：**

**C++本质上是对C语言的扩展，因此C++程序也可以直接调用C语言中的函数**。只需要在C++代码中包含C语言头文件，并使用extern "C"来指定函数名的修饰规则。例如：

C代码:

```
int MyFunction(int a, int b) {
    return a + b;
}
```

C++代码：

```
#include <stdio.h>

extern "C" {
    int MyFunction(int a, int b); // 声明C语言函数
}

int main() {
    int result = MyFunction(1, 2);
    printf("result = %d", result);
    return 0;
}
```

注意，由于C++和C语言使用不同的名称修饰规则，因此需要使用**extern** "C"来指定函数名的修饰规则，以便C++编译器可以正确地调用C语言函数。



### 69用组合为什么不用继承？

低耦合高内聚

二者的主要区别在于继承是一种**"is-a"的关系**，而组合是一种"**has-a"的关系。**

使用组合而不是继承的原因可能有以下几个方面：

1. **避免类层次结构的复杂性：继承会形成一种类层次结构，容易导致类的数量急剧增加，而且修改父类可能会影响所有的子类。组合则不具备这种问题，因为每个对象都是独立的，修改一个对象不会影响其他对象。**
2. 总之，使用组合而不是继承的原因在**于组合可以提供更灵活和高效的对象管理方式，避免类层次结构的复杂性，并且代码可读性更高。**

### 70邻接矩阵是什么？

**邻接矩阵是一种图的表示方法**，用于描述图中各个节点之间的关系。对于一个有n个节点的图，**邻接矩阵是一个n x n的矩阵**，其中第i行第j列的元素表示节点i到节点j之间是否有边相连。如果节点i到节点j之间有边相连，则矩阵中对应的元素值为1，否则为0。



### 71适配器模式？

适配器模式是一种结构型设计模式，**它的作用是将一个类的接口转化为客户端所期望的另一种接口，从而使原本不兼容的接口能够协同工作**。

### 72形参为什么加const，为什么加引用？

**形参加const的主要目的是为了保证函数内部不会修改到形参所指向的值**，从而**提高程序的可维护性和安全性**。**如果一个函数需要读取数据而不需要修改数据，那么应该将相关的形参声明为const类型。**这样做不仅可以让函数自身更加安全，而且还可以使得函数调用更加清晰明了。

形参加引用的主要目的是为了**避免函数调用时**产生的**数据拷贝**，从而提高程序的效率和性能。**使用引用作为函数形参可以让函数直接操作实参所指向的内存空间**，而不是通过拷贝数据的方式来进行操作。这在处理大量数据或者大型对象时，可以避免产生过多的内存开销和数据拷贝的时间开销。

**当形参既需要保证函数内部不修改实参的值，又需要避免产生数据拷贝时，可以同时使用const和引用**，例如：

```c++
void foo(const std::vector<int>& vec);
```

上述函数声明表示foo函数的形参vec是一个指向const std::vector类型的引用，即foo函数无法修改vec所指向的容器值，并且在函数调用时也不会对vec所指向的容器进行数据拷贝。这样做不仅能够保证数据的安全性，而且还能够提高函数的效率和性能。

### 73write是阻塞的吗？

1 当调用write函数时，如果写入的数据量小于缓冲区大小，则write操作是原子的，数据被写入缓冲区，函数立即返回。

2 如果写入的数据量大于缓冲区大小，**write函数会阻塞等待**，在阻塞期间，进程会被挂起，无法继续执行其他操作，直到write操作完成或出现错误。



如果需要在写入数据时不阻塞进程，可以将文件描述符设置为**非阻塞模式**，这样调用write函数时将不会阻塞。可以使用**fcntl系统调用**来设置文件描述符的属性，例如：

```c
int fd = open("file.txt", O_WRONLY);
fcntl(fd, F_SETFL, O_NONBLOCK);

char buf[1024];
int nwrite;
while ((nwrite = write(fd, buf, sizeof(buf))) == -1 && errno == EAGAIN) {
    // do something else, such as sleep or poll
}
if (nwrite == -1) {
    // handle error
}
```

在设置为非阻塞模式后，调用write函数时如果缓冲区已满，write函数会立即返回-1，并设置errno为EAGAIN或EWOULDBLOCK，表示需要再次尝试写入数据。此时可以调用其他系统调用，如sleep或poll等，等待文件描述符变为可写状态后再次尝试写入数据。

### 68实现strncpy

strncpy是C标准库中的字符串拷贝函数，用于将源字符串的前n个字符拷贝到目标字符串中，并返回指向目标字符串的指针。其函数声明如下：

```c
char *strncpy(char *dest, const char *src, size_t n);
```

其中，dest表示目标字符串的指针，src表示源字符串的指针，n表示拷贝的字符个数。

一个简单的实现方式如下：

```c
char *strncpy(char *dest, const char *src, size_t n) {
    size_t i;
    for (i = 0; i < n && src[i] != '\0'; i++) {
        dest[i] = src[i];
    }
    for (; i < n; i++) {
        dest[i] = '\0';
    }
    return dest;
}
```

该实现方式使用两个循环，**第一个循环用于拷贝源字符串的前n个字符到目标字符串中，第二个循环用于将目标字符串中剩余的位置填充为'\0'。**

需要注意的是，**当源字符串的长度小于n时，目标字符串可能不会以'\0'结尾，因此在使用该函数时需要特别小心，以避免出现越界访问等问题。**

### 74面向对象的优点

1. 抽象和封装：更加灵活、可维护性更好。
2. 继承：**继承使得子类可以继承父类的属性和方法**，**避免了重复编写代码**，
3. 多态：**多态使得不同对象可以对同一消息（方法调用）作出不同的响应**，这种灵活性提高了程序的可扩展性和可维护性。
4. **模块化**：面向对象编程将程序分解成相互独立，可复用的模块，使得程序的组织结构更加清晰，易于维护和升级。
5. **安全性**：**面向对象编程可以控制访问权限**，避免了数据被破坏或者误用，提高了系统的安全性。
6. **可移植性**：面向对象编程通过封装和抽象，使得程序与操作系统、硬件平台等无关，使得程序更具有可移植性。

### 75fopen和open的区别，哪个是带缓冲的，如果想定时将文件内容写入磁盘应该怎么操作？

| fopen                                    | open                             |
| :--------------------------------------- | -------------------------------- |
| 标准库函数                               | 系统调用函数                     |
| fopen返回一个指向文件的指针              | open返回文件描述符               |
| 缺点是**速度较慢**，因为它要进行缓冲操作 | open是直接操作文件，**速度较快** |
| fopen是带缓冲的函数                      |                                  |



### 76菱形继承产生的二义性

菱形继承是指在类继承结构中，**派生类同时继承了两个直接或间接基类，而这两个基类又公共地继承了一个共同的基类**。这种继承关系会导致二义性问题的产生，称为菱形继承问题。

在菱形继承中，派生类同时继承了两个基类的成员变量和成员函数，并且这两个基类中都有一个共同基类，因此派生类中就会有两份共同基类的成员变量和成员函数，这就造成了二义性问题。

例如：

```
class A {
public:
    int x;
};

class B : public A {};

class C : public A {};

class D : public B, public C {};

int main() {
    D obj;
    obj.B::x = 1;
    obj.C::x = 2;
    // Which x should the following line access?
    std::cout << obj.x << std::endl;
    return 0;
}
```

在这个例子中，类D同时继承类B和C，而类B和C又都继承了类A。因此在类D中就会出现两个x变量，**此时当访问obj.x时，编译器无法确定应该访问哪一个x，从而导致二义性问题。**

为了解决菱形继承问题，可以采用**虚继承**。虚继承相对于普通继承来说，会在派生类中只保留一份虚基类的成员变量和成员函数，从而避免了二义性问题。因此，在继承结构中，对于共同的基类，应该将其设置为虚基类。例如：

```
class A {
public:
    int x;
};

class B : virtual public A {};

class C : virtual public A {};

class D : public B, public C {};

int main() {
    D obj;
    obj.B::x = 1;
    obj.C::x = 2;
    // Now obj.x is unambiguous.
    std::cout << obj.x << std::endl;
    return 0;
}
```

在这个例子中，类B和C均采用了虚继承，因此在类D中只会有一个x变量，这样访问obj.x时就不会出现二义性问题了。

### 77写一个线程安全的单例模式单例模式的构造函数？单例模式的创建过程？如何保证线程安全？(为完成)







### 78说一说strcpy、sprintf与memcpy这三个函数的不同之处

三个函数的不同点如下：

1. strcpy函数用于**将一个字符串复制到另一个字符串中**，可用于拷贝C风格字符串，但不能用于拷贝二进制数据。
2. sprintf函数用于将**格式化的字符串输出到另一个字符串中**。它可以处理各种数据类型的格式化输出，但同样不能用于拷贝二进制数据。
3. memcpy函数用**于拷贝二进制数据**，它以字节为单位拷贝一定数量的数据，可以用于拷贝字符串和其他二进制数据。

### 79 C++中const和static的作用

const和static都是C++中常用的关键字，它们有不同的作用。

const的作用：

1. 定义常量：可以将变量声明为const类型，在程序运行过程中该变量的值不可改变。
2. 防止修改函数参数：可以将函数参数声明为const类型，防止函数内部修改该参数的值。
3. 类中成员变量声明为const：类中可以将成员变量声明为const类型，防止在类外部被修改。
4. 安全性：能够避免因意外的修改而导致的错误。

static的作用：

1. 静态变量：可以将变量声明为静态变量，静态变量在程序运行期间只分配一次内存，在程序的声明周期中都可以使用。
2. 静态函数：可以将函数声明为静态函数，静态函数在程序的声明周期中只被分配一次内存，在程序中所有的对象都可以调用。
3. 静态成员变量：可以将类的成员变量声明为静态成员变量，静态成员变量是该类的所有对象共享的。
4. 作用范围：静态变量和静态函数只能在当前文件中使用，该文件中的所有函数都可以访问它们。
5. 内部实现：静态变量和静态函数的实现和普通变量和函数不同，它们在程序编译时就已经分配了内存空间。

### 80C++中函数指针和指针函数的区别？

在C++中，函数指针和指针函数是两个不同的概念。

1. 函数指针

函数指针是**指向函数的指针变量**，可以存储一个**函数的地址以及调用该函数。**

例如，以下代码定义了一个函数指针变量，指向一个返回值为int类型，参数为两个int类型的函数：

```c++
int (*pFunc)(int, int);
```

其中，`pFunc`是一个指向函数的指针变量，可以通过给它赋值来使它指向一个函数：

```c++
int add(int a, int b) {
    return a + b;
}

pFunc = add;
```

这里，我们将`add`函数的地址赋给了`pFunc`变量，现在可以通过调用`pFunc`来调用`add`函数了：

```c++
int result = pFunc(1, 2); // result = 3
```

1. 指针函数

**指针函数是一个返回值为指针类型的函数**，它返回的是一个指针，可以用于动态分配内存、返回数组等操作。

例如，以下代码定义了一个指针函数，它返回一个int类型的指针：

```c++
int* func() {
    int* p = new int(10);
    return p;
}
```

在这个例子中，`func`函数动态分配了一个int类型的内存，并返回了这个内存的地址。可以将这个地址保存到一个指针变量中：

```c++
int* p = func();
```

现在，`p`变量包含了函数`func`动态分配的内存的地址，可以通过它来访问和修改这个内存：

```c++
(*p) = 42;
std::cout << (*p) << std::endl; // 42
```

综上所述，函数指针和指针函数是C++语言中两个不同的概念，有不同的用途和应用场景，需要根据实际情况进行选择和使用。

### 81指针和引用的区别

| 指针                                                  | 引用                                                   |
| ----------------------------------------------------- | ------------------------------------------------------ |
| int* p                                                | int& r                                                 |
| 指针可以改变它所指向的变量的值                        | 引用本质上是变量的别名，在使用过程中不会改变原变量的值 |
| 指针可以定义为空指针                                  | 引用必须始终指向一个变量，因此不能定义为空             |
| 指针可以使用运算符`*`和`->`来访问它所指向的变量和成员 | 引用没有自己的地址，因此不能使用运算符`*`和`->`。      |
| 作为函数参数，指针传递的是变量的地址                  | 作为函数参数，引用传递的是变量本身                     |
|                                                       |                                                        |

### 82 引用作为函数返回时为什么不能返回局部变量？

在C++中，**当一个函数返回一个引用时，引用实际上是指向函数内部的一个对象或变量的别名**。因此，**如果函数返回一个指向局部变量的引用**，**意味着引用将指向存储在栈上的临时对象。**

**当函数返回时，函数栈被销毁，局部变量的内存空间被释放。如果返回的是一个指向局部变量的引用，那么这个引用指向的内存空间已经被释放，这时再使用这个引用会导致未定义行为**。

例如：

```C++
int& get_local_var() {
    int x = 10;
    return x;
}

int main() {
    int& ref = get_local_var();
    std::cout << ref << std::endl; // 这里引用的是已经被释放的内存，是未定义行为
    return 0;
}
```

在这个例子中，get_local_var函数返回一个对局部变量x的引用。当函数返回时，局部变量x的内存空间被释放，因此在main函数中再使用这个引用的时候会导致未定义行为。

为了避免这种情况发生，可以把返回类型改为值类型或指针类型，或者将局部变量声明为静态变量或函数的静态变量，这样就可以保证返回值在函数调用结束后仍然存在于内存中。

### 84  内联函数和宏定义的区别

|              | 内联函数                                                     | 宏定义                                                       |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 参数类型检查 | 而内联函数需要定义一个函数体，编译器可以对参数类型进行检查，保证类型匹配，减少错误的发生。 | 宏定义不做任何参数类型检查，仅仅是简单的文本替换             |
| 符号表       | 而内联函数需要在符号表中有自己的记录，这使得调试器可以跟踪到内联函数的执行 | 宏定义会在编译预处理阶段被展开，即将宏定义的名称替换成它的内容。这意味着在符号表中，不会有任何关于这个宏定义的记录 |
| 编译器优化   | 内联函数由编译器决定是否进行内联展开，通常只有函数体非常短小、调用次数非常频繁时才会进行内联展开 | 而宏定义则总是会被展开，即使宏定义只被调用了一次。           |
| 命名空间     | 而内联函数是定义在类或命名空间中的，它只在定义所在的命名空间或类中起作用。 | 宏定义不会受到命名空间的限制，它在全局范围内起作用。         |
| 宏定义的缺陷 | 而内联函数则可以解决这些问题，可以使代码更容易被维护和阅读。 | 导致代码可读性变差、它是文本替换，可能会引起一些意外的错误等 |
|              |                                                              |                                                              |



### 86 静态变量什么时候初始化

静态变量在C++中有两种情况下会被初始化：

1. **函数内静态变量**

**当一个静态变量定义在函数内部时，在第一次调用函数时会被初始化**，之后不再进行初始化。例如：

```cpp
void func()
{
    static int var = 10; // 静态变量
    // code
}
```

在第一次调用`func`时，`var`会被初始化为10，以后再调用`func`时不会再次初始化。

1. **全局/命名空间静态变量**

**当一个静态变量在全局或命名空间中被定义时，在程序启动时就会被初始化**。例如：

```cpp
static int var = 10; // 全局静态变量
namespace ns {
    static int var2 = 20; // 命名空间中的静态变量
}
```

在程序启动时，`var`和`var2`都会被初始化为10和20。

需要注意的是，**如果一个静态变量未被初始化，那么它的值默认为0。**如果在定义时初始化了一个静态变量，那么每次程序启动都会把它的值恢复到初始化时的值。此外，在多个源文件中定义同名的静态变量，这些源文件会将这些静态变量看作是不同的变量。

总之，静态变量的初始化时间取决于它们的作用域和定义位置，在程序启动时被初始化或在函数第一次调用时被初始化。程序员需要根据实际需要，合理使用和管理静态变量。

### 87动态编译与静态编译



**静态编译是在程序编译的时候将程序源代码和库文件一同编译**，**生成可执行文件**。这个可执行文件中包含了所有需要使用的库函数和静态链接库，因此在程序运行时不需要依赖任何其他库。

静态编译的**优点**是生成的可执行文件比较小，运行速度较快，也比较容易分发和部署。

但**缺点**是编译时间比较长，占用磁盘空间也较大，而且无法动态更新库文件，需要重新编译整个程序。

**动态编译是在程序运行时，根据需要动态加载程序所需的库文件**，**生成一个共享库，然后程序动态链接这个库文件。**

动态编译的**优点**是可以在运行时动态地加载和卸载库文件，减少了程序的启动时间，也方便了库文件的更新和管理。

但**缺点**是需要依赖其他库文件，不能脱离依赖单独运行，而且运行速度可能会受到动态链接库的影响。

一般来说，

**如果程序需要频繁部署和更新，或者需要处理较大的数据集，可以选择静态编译；**

**如果程序需要频繁调用库函数，或者需要动态加载和卸载库文件，可以选择动态编译。**

### 88C++和C的struct区别

在C++中，struct是一种复合数据类型，它可以包含不同类型的数据成员和成员函数。

**与C不同的是，在C++中，struct可以继承其他结构体或类，可以自定义构造函数、析构函数等。此外，在C++中，struct的默认访问权限是public。**

**在C中**，struct同样是一种复合数据类型，**但它只能包含数据成员**，**不支持成员函数和继承**。在C中，struct的默认访问权限是private。

因此，C++中的struct更加强大和灵活，它支持C中不具备的特性，比如继承、多态、封装等面向对象的概念。而在C中，struct主要是用来组织和管理数据，结构体内部的成员是公共的，可以被直接访问。

在使用struct时，需要注意的是，在C++中，结构体的定义和使用更加严格，需要遵循C++的规范，否则可能会导致编译错误或运行错误。而在C中，结构体的定义和使用比较灵活，但也需要注意一些细节问题，比如结构体对齐等。

### 89拷贝构造函数的调用时机

在 C++ 中，拷贝构造函数是一种特殊的构造函数，**用于在创建一个对象时使用另一个同类型的对象来初始化它。**在拷贝构造函数中，我们通常会把另一个对象的数据成员复制到当前对象中，以实现两个对象拥有相同数据的效果。

在 C++ 中，对象的拷贝构造函数会在下列情况下被自动调用：

1. **当用一个对象初始化另一个同类型的对象时：**

```cpp
MyClass obj1; // 定义了一个 MyClass 类型的对象 obj1
MyClass obj2(obj1); // 使用 obj1 来初始化 obj2，会调用拷贝构造函数
```

1. **当函数的参数是类的对象时，以值传递的方式调用函数时：**

```cpp
void func(MyClass obj) {
    // code
}

int main() {
    MyClass obj1;
    func(obj1); // 以值传递的方式调用函数 func，会调用拷贝构造函数来初始化 obj 参数
    return 0;
}
```

1. **当函数的返回值是类的对象时：**

```cpp
MyClass func() {
    MyClass obj;
    // code
    return obj; // 返回 obj 对象，会调用拷贝构造函数来构造返回值
}

int main() {
    MyClass obj = func(); // 接收函数返回值，会调用拷贝构造函数来初始化 obj
    return 0;
}
```

需要注意的是，**调用拷贝构造函数时，编译器会自动生成一个默认的拷贝构造函数，但这个默认的拷贝构造函数只是简单地复制数据成员的值，如果类中存在指针等需要深拷贝的成员，就需要自己提供一个合适的拷贝构造函数。同时，为了能够避免拷贝对象的构造函数被多次调用，在拷贝构造函数的实现中一般使用引用来传递对象，而不是按值传递对象。**

### 90为什么拷贝构造函数必须传引用不能传值？

**在 C++ 中，拷贝构造函数的传参一般使用引用而不是值的方式来进行。这是因为如果使用值传递参数，则会涉及到对象的拷贝过程，需要调用拷贝构造函数，从而增加程序的开销和额外的内存使用。**

**如果使用值传递，会导致传递的对象重新构造一份，这会增加额外的内存使用，还会降低程序的效率。因此，使用引用作为参数可以避免这种情况，不会增加额外的内存使用，也不会影响程序的效率。**

**此外，使用引用作为参数可以避免对象的无限递归拷贝，因为在拷贝构造函数中，如果使用值传递参数，则调用的拷贝构造函数会不断地调用自己，造成无限循环调用，直到程序崩溃。**

综上所述，**拷贝构造函数必须传引用而不能传值，可以避免对象的拷贝和无限递归拷贝，减少内存使用，提高程序的效率。**

### 91  零拷贝技术

而**零拷贝技术通过优化传输过程，可以在不复制数据的情况下将数据从源地址传输到目标地址，从而减少数据传输过程中的数据复制。**



### 92  类中静态函数占用内存么

在 C++ 中，**静态函数是属于类**而**不是对象的**，因此它**不会占用类的对象的内存空间，也不需要创建对象才能调用**。静态函数与类关联而不是与类对象关联，因此**它的内存空间在程序启动时就已经分配好了，不会占用额外的内存空间**。

虚函数是实现C++中多态的机制，通过虚函数可以实现在父类和子类中有相同名称的函数，调用对象的函数将根据对象的实际类型来调用相应的函数。**虚函数的实现原理是在类的虚函数表中存储函数的地址，通过访问对象的虚函数指针来动态调用虚函数**。

**虚函数表是在编译阶段生成的，存放类中所有虚函数的地址**。虚函数表是由编译器生成的，它会在编译时根据声明的虚函数数目为每个类生成一个虚函数表，虚函数表内存中的内容是固定的，不可更改。

在程序的运行期间，**每个类的对象都会包含一个指向虚函数表的指针——虚函数表指针，该指针指向类的虚函数表**。当对象调用一个虚函数时，程序会根据虚函数表指针找到该类的虚函数表，并根据函数在虚函数表中的位置来调用相应的函数。

总之，静态函数不占用类对象的内存空间，虚函数表在编译阶段生成，并存储类中所有虚函数的地址，程序运行时通过虚函数表指针来访问虚函数表并动态调用虚函数。

### 93      C++的多态如何实现

**五步走**



C++中的多态可以通过**虚函数和指针或引用来实现**。在基类中声明虚函数，在派生类中重写虚函数实现多态。当基类指针或引用指向派生类对象时，调用虚函数时会按照派生类的实现进行调用，实现多态。以下是一个示例：

```
#include<iostream>

using namespace std;

class Shape {
public:
    virtual double getArea() {
        return 0;
    }
};

class Rectangle : public Shape {
public:
    Rectangle(double w, double h) : width(w), height(h) {}
    double getArea() {
        return width * height;
    }
private:
    double width, height;
};

class Circle : public Shape {
public:
    Circle(double r) : radius(r) {}
    double getArea() {
        return 3.14 * radius * radius;
    }
private:
    double radius;
};

int main() {
    Shape* shape1 = new Rectangle(2, 3);
    Shape* shape2 = new Circle(4);

    cout << "Rectangle area: " << shape1->getArea() << endl;
    cout << "Circle area: " << shape2->getArea() << endl;

    delete shape1;
    delete shape2;
    return 0;
}
```

输出结果：

```
Rectangle area: 6
Circle area: 50.24
```

在这个示例中，Shape类是基类，Rectangle和Circle类是派生类。每个子类都重写了getArea()函数，实现了多态。使用基类指针shape1和shape2分别指向Rectangle和Circle对象，调用它们的getArea()函数，实现了多态性。

### 94 虚函数表里存放的内容是什么时候写进去的？（编译阶段）

虚函数表是在编译阶段生成的，存放在程序内存的代码段或数据段中。

在类中定义虚函数时，编译器会为该类生成一个虚函数表，其中存放了该类所有的虚函数地址，每个对象都会在内存中分配一个指向该类虚函数表的指针，用于动态调用虚函数。

虚函数表的构建是由编译器自动完成的，根据类的继承层次，每个类都有自己的虚函数表，虚函数表中存储的是该类及其父类的虚函数指针。编译器在编译类的时候，会为每个带有虚函数的类创建虚函数表，并在类的构造函数中为虚函数表指针赋值。

因此，虚函数表的内容是在编译阶段就已经写入程序代码中的，而不是在运行时动态生成的。

### 95 虚函数和纯虚函数的区别

因此，当**需要派生类必须实现的函数时，使用纯虚函数**；**否则可以使用虚函数提供默认实现，让派生类选择是否重写**。同时，如果需要设计接口，则应该使用纯虚函数来定义接口规范。

| 虚函数                                                       | 纯虚函数                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 可以在基类中有默认实现，派生类可以选择重写或不重写该函数     | 在基类中没有默认实现，必须在派生类中重写实现。               |
| 而虚函数即使没有被实现也可以实例化，只是在调用时会使用默认实现。 | 类中只要包含至少一个纯虚函数，该类就被称为抽象类，不能被实例化 |
| 而虚函数不能作为强制实现的接口，只能在派生类中选择性地重写   | 具有纯虚函数的抽象类可以用作接口，强制该类的所有子类都实现相同的纯虚函数 |



### 96为什么析构函数一般写成虚函数

C++中，如果一个类定义了虚函数（包括纯虚函数），那么这个类的析构函数也应该声明为虚函数。

这是因为**如果一个基类有派生类，那么在删除一个指向派生类的基类指针时，如果该基类的析构函数不是虚函数，那么只会调用基类的析构函数，而不会调用派生类的析构函数，这就可能导致内存泄漏等问题。**

**如果一个类有派生类，并且这个类的析构函数声明为虚函数，那么在删除一个指向派生类的基类指针时，会先调用派生类的析构函数，然后再调用基类的析构函数，这样可以保证释放所有派生类的资源。**

因此，为了实现正确的继承和多态，析构函数一般写成虚函数。

### 97模板和实现可不可以不写在一个文件里面？为什么？



### 100  weak_ptr如何解决shared_ptr的循环引用问题？

weak_ptr是C++11引入的一种智能指针，用于解决**shared_ptr的循环引用问题。**在

循环引用的情况下，**每个指针都持有另一个指向同一个对象的指针，导致引用计数无法为0，从而对象无法被正确释放。**

**weak_ptr是一种不控制对象生命周期的智能指针**，**它指向一个由shared_ptr管理的对象，并可以获取该对象的弱引用**。与shared_ptr不同，weak_ptr并不会增加对象的引用计数，也不会延长对象的生命周期。**因此，当所有shared_ptr都离开作用域或被释放时，对象的引用计数会变为0，被正确地销毁，而不会因循环引用无法释放**。

通过使用weak_ptr，**我们可以在需要访问被shared_ptr管理的对象时，通过lock()方法获取一个指向该对象的shared_ptr，这个shared_ptr会增加对象的引用计数，从而确保对象的有效性。当需要使用结束后，这个shared_ptr会自动销毁，对象引用计数也会相应地减少。**

因此，**weak_ptr主要解决shared_ptr的循环引用问题，用于辅助shared_ptr进行资源管理。**

------

shared_ptr在循环引用时会导致内存泄漏，因为指针的引用计数无法降为0，对象无法被释放。weak_ptr可以解决这个问题，它是一种不管理内存的智能指针，它可以指向被shared_ptr管理的对象，但不会增加其引用计数，因此也不会影响内存的释放。

下面是一个例子，演示shared_ptr循环引用问题以及使用weak_ptr解决问题的过程：

```
class A {
public:
    std::shared_ptr<A> ptr;  // 管理A对象的shared_ptr
    A() { std::cout << "A constructor" << std::endl; }
    ~A() { std::cout << "A destructor" << std::endl; }
};

int main() {
    std::shared_ptr<A> pA1(new A());
    std::shared_ptr<A> pA2(new A());
    pA1->ptr = pA2; // pA1管理pA2
    pA2->ptr = pA1; // pA2管理pA1
    return 0;
}
```

上面的代码中，**pA1和pA2相互管理，形成了循环引用，导致对象无法被释放**。为了解决这个问题，可以将pA2的ptr成员改为weak_ptr类型：

```
class A {
public:
    std::weak_ptr<A> ptr;  // 不管理A对象的weak_ptr
    A() { std::cout << "A constructor" << std::endl; }
    ~A() { std::cout << "A destructor" << std::endl; }
};

int main() {
    std::shared_ptr<A> pA1(new A());
    std::shared_ptr<A> pA2(new A());
    pA1->ptr = std::shared_ptr<A>(pA2); // pA1管理pA2
    pA2->ptr = std::shared_ptr<A>(pA1); // pA2管理pA1
    return 0;
}
```

这样，pA2的引用计数不再增加，pA1中的shared_ptr会在离开作用域时自动释放，pA2中的weak_ptr也会在离开作用域时被自动删除，**因此循环引用问题得到了解决。**

------



### 102四种强制类型转换及应用场景

。常见的四种强制类型转换和应用场景如下：

1. **static_cast**：**静态类型转换**，用于基本数据类型的转换、对象指针和void指针之间的转换、基类指针和派生类指针之间的转换。例如：

```
double a = 3.14;
int b = static_cast<int>(a); // 将double类型转换为int类型
```

1. **dynamic_cast**：**动态类型转换**，**主要用于类的继承中，将基类指针或引用转换为派生类指针或引用**。例如：

```
class Base { virtual void func() {} };
class Derived : public Base {};

Base* pBase = new Derived();
Derived* pDerived = dynamic_cast<Derived*>(pBase); // 将基类指针转换为派生类指针
if (pDerived != nullptr) {
  // 转换成功，进行派生类相关操作
}
```

1. **reinterpret_cast**：**重新解释类型转换，用于任何类型之间的转换**。例如将指针类型转换为整数类型或将整数类型转换为指针类型。例如：

```
int a = 42;
void *pVoid = reinterpret_cast<void*>(&a); // 将int指针转换为void指针
```

1. **const_cast：去掉const属性的类型转换，用于将const类型转换为非const类型**。例如：

```
void func(const int& a) {
  int& b = const_cast<int&>(a); // 将const类型转换为非const类型
  b = 10;
}

int main() {
  int a = 5;
  func(a); // 传入非const类型
  return 0;
}
```

需要注意的是，强制类型转换可能会导致类型错误或不安全的操作，需要谨慎使用。

### 103左值&右值

左值（Lvalue）和右值（Rvalue）是表达式（expression）这一概念中的两个术语。

左值指的是表达式的结果可以作为赋值操作的对象，即表达式的值可以出现在等号左边，例如变量、数组元素、类成员等等。通俗的理解，**左值就是可以取地址**的表达式。

右值则指的是表达式的结果不能作为赋值操作的对象，即表达式的值只能出现在等号右边，例如字面常量、函数调用的返回值等等。通俗的理解，**右值就是不能取地址**的表达式。

例如：

```cpp
int a = 1;  // a是左值，1是右值
int b = a;  // a是左值，b是左值
int* p = &a;  // a是左值，&a是左值，p是左值
int sum = a + b;  // a和b都是左值，+运算的结果是右值
```

需要注意的是，C++11引入了**右值引用（**Rvalue reference）的概念，允许将右值绑定到具有右值引用类型的变量上，因此右值不一定总是无法作为赋值操作的对象。右值引用类似于左值引用（Lvalue reference），但只能绑定到右值。

例如：

```cpp
int&& r = 1;  // 将1作为右值绑定到r上
int a = 1;
int&& r2 = std::move(a);  // 将a作为右值绑定到r2上
```

总的来说，左值和右值是表达式的两个重要概念，理解它们的区别有助于更好地理解C++中的表达式和赋值操作。

### 104 创建一个空类编译器做了哪些事

编译器在创建一个空类时，大致会做以下几件事情：

1. 识别**类的定义**：编译器会识别出类的名称和定义，包括类的成员变量和成员函数等。
2. 确定**类的大小**：编译器需要确定类的大小，即占用的内存空间大小。空类并不会包含任何成员变量，所以它的大小为0。
3. 自动生成**默认构造函**数：如果没有手动定义构造函数，编译器会为类自动生成默认构造函数，以便可以创建类的对象。
4. 自动生成**默认析构**函数：同样，如果没有手动定义析构函数，编译器会为类自动生成默认析构函数，以便可以正确地释放类的对象。
5. 自动**生成拷贝构造函数和赋值操作符**：如果没有手动定义拷贝构造函数和赋值操作符，编译器会为类自动生成默认的拷贝构造函数和赋值操作符，以便可以进行对象的拷贝和赋值。
6. 生成类的类型信息：编译器需要生成类的类型信息，以便在程序运行时可以正确地进行类型检查和类型转换。
7. 分配**类的对象内存**：当程序创建类的对象时，编译器需要分配一段内存空间来存储该对象的成员变量和函数指针等信息。

总之，虽然空类并不包含成员变量和成员函数，但编译器仍然需要为它生成默认构造函数、默认析构函数、默认拷贝构造函数和赋值操作符等函数，并且为它分配内存空间。

### 105  枚举类型和结构体有什么区别



| 枚举                                           | 结构体                                           |
| ---------------------------------------------- | ------------------------------------------------ |
| 由一组具有相同类型的枚举常量组成               | 由多个不同类型的成员变量组成。                   |
| 枚举类型的取值只能在枚举常量中选择             | 结构体的每个成员变量都可以赋予任意的值           |
| 一组常量的集合                                 | 一组变量的集合                                   |
| 枚举类型的常量之间没有任何关系                 | 而结构体中的变量之间是有联系的                   |
| 枚举类型可以将常量组合用于控制程序的流程或行为 | 结构体可以将多个变量结合在一起形成一个逻辑整体。 |

枚举类型和结构体都是C++中的自定义数据类型，但它们的应用场景和特点不同。

枚举类型用于定义一组常量，常用于程序中需要对某个变量进行限定的情况，可以有效避免魔数（Magic Number）问题。枚举类型定义的常量都是整数类型，可以通过枚举变量来访问。例如：

```
enum Color { RED, GREEN, BLUE };
Color color = RED;
if (color == RED) {
    // do something...
}
```

结构体则是将多个变量打包成一个数据类型，有利于形成逻辑上的整体，便于处理。结构体中的变量可以是不同类型的，可以是基本类型、数组、指针、类对象等。例如：

```
struct Person {
    int age;
    std::string name;
    void sayHello() { std::cout << "Hello, my name is " << name << std::endl; }
};
Person p = { 20, "Alice" };
std::cout << p.name << " is " << p.age << " years old." << std::endl;
p.sayHello();
```

两者的主要区别在于枚举类型是一组常量的集合，而结构体是一组变量的集合。枚举类型的常量之间没有任何关系，而结构体中的变量之间是有联系的。枚举类型可以将常量组合用于控制程序的流程或行为，而结构体可以将多个变量结合在一起形成一个逻辑整体。

### 106    ++i和i++

++i和i++都是自增运算符，不同的是++i是前置自增运算符，i++是后置自增运算符。

前置自增运算符++i的作用是先对i进行自增操作，再将自增后的i的值作为表达式的值返回。因此，++i是一个左值，可以出现在赋值语句的左侧，例如++i = 2;。

后置自增运算符i++的作用是先将i的值作为表达式的值返回，再对i进行自增操作。因此，i++是一个右值，不能出现在赋值语句的左侧。

例如：

```c++
int i = 1;
int a = ++i; // a = 2, i = 2
int b = i++; // b = 2, i = 3
```

在第一行代码中，先执行自增操作，i的值变为2，再将i的值赋给a，因此a的值为2。

在第二行代码中，先将i的值赋给b，b的值为2，再执行自增操作，i的值变为3。

因此，++i和i++的区别在于它们的返回值和副作用的顺序不同。

### 108不同继承方式的访问权限

不同的继承方式有三种：公有继承、私有继承和保护继承。在这三种不同的继承方式中，访问权限也是不同的。

| **继承**         | **基类**  | **派生类(public下)**                   | **派生类的对象调用基类** |
| ---------------- | --------- | -------------------------------------- | ------------------------ |
| ：public 基类    | public    | 可访问基类的public                     | yes                      |
|                  | protected | 对基类的protected访问权限还是protected | no                       |
|                  | private   | 不可访问基类private                    | no                       |
| ：protected 基类 | public    | 对基类的public访问权限是protected      | no                       |
|                  | protected | 对基类的protected访问权限还是protected | no                       |
|                  | private   | 不可访问基类private                    | no                       |
| ：private 基类   | public    | 不可访问基类public                     | no                       |
|                  | protected | 不可访问基类protected                  | no                       |
|                  | private   | 不可访问基类private                    | no                       |

### 109说一说你了解的关于lambda函数的全部知识

Lambda函数是一种**匿名函数，也称为函数字面量。它可以在不定义函数名称的情况下定义并创建函数对象**。以下是我的全部知识：

1. Lambda函数可以接受任意数量的参数，并返回一个表达式的结果。
2. Lambda函数语法是使用lambda关键字，后面跟一个或多个参数，然后是冒号（：）和一个表达式。
3. **Lambda函数可以作为参数传递给其他函数，通常用于编写高阶函数。**
4. Lambda函数的主要优点是可以更容易地编写简单的函数逻辑并减少代码行数。
5. Lambda函数的缺点是它们不能放置复杂的逻辑代码和语句块。
6. Lambda函数在函数式编程中使用非常广泛，例如在map、filter、reduce等函数中。
7. Lambda函数被广泛应用于Python中的许多库和框架，如Django、Flask等。
8. Lambda函数可以与列表解析一起使用，以更简洁的方式生成列表。
9. Lambda函数可以使用闭包从外部范围捕获变量，并在函数内部引用这些变量。
10. Lambda函数可以使用装饰器进行修饰，增强函数的功能。



下面是一些lambda表达式的例子：

1. 简单的 lambda 表达式，将两个数字相乘：

```
auto multiply = [](int a, int b) {
    return a * b;
};
std::cout << multiply(3,4) << std::endl; //输出12
```

1. 使用 lambda 表达式作为算法的参数，排序一个 vector：

```
std::vector<int> v { 1, 4, 2, 8, 5 };
std::sort(v.begin(), v.end(), [](int a, int b) {
    return a < b;
});
for (int i : v) { std::cout << i << " "; } //输出 1 2 4 5 8
```

1. 捕获外部变量并修改：

```
int x = 10;
auto changeX = [&x]() {
    x = 20;
};
changeX();
std::cout << x << std::endl; //输出20
```

1. 捕获外部变量并使用：

```
int x = 10;
int y = 5;
auto addXY = [x, &y]() {
    return x + y;
};
std::cout << addXY() << std::endl; //输出15
```

1. 使用 lambda 表达式作为容器的遍历器：

```
std::vector<int> v { 1, 4, 2, 8, 5 };
std::for_each(v.begin(), v.end(), [](int i) {
    std::cout << i << " ";
}); //输出 1 4 2 8 5
```

Lambda表达式支持的操作非常灵活，可以用于定义函数、作为参数传递、捕获外部变量等，能够大大简化代码编写和维护。

### 110 C++中的智能指针？三种指针解决的问题以及区别？

C++中的**智能指针是一种通过 RAII（Resource Acquisition Is Initialization）**技术自动管理内存生命周期的指针。C++标准库提供了三种智能指针：std::unique_ptr、std::shared_ptr和std::weak_ptr。

三种指针解决的问题：

1. std::unique_ptr：**用于管理单个对象的生命周期，保证内存释放的安全性**。一个unique_ptr对象拥有对其所指向的对象的独有权，不能与其他unique_ptr对象共享同一个对象。**当unique_ptr对象被销毁时，它所指向的对象也会被自动销毁。**
2. std::shared_ptr**：用于管理多个对象的生命周期，支持多个指针共享同一个对象。它采用计数引用的方式，每个与之关联的shared_ptr对象共享同一个计数器，当计数器变为0时，它所管理的对象也会被自动销毁。**
3. std::weak_ptr：是一种弱引用，指向由shared_ptr所管理的对象，但不会改变对象的引用计数。它不会增加对象的计数器，即使所有的shared_ptr都已经被销毁，weak_ptr也可以通过lock方法获得一个有效的shared_ptr，从而访问该对象。

三种指针的区别：

1. **所管理的对象数**：unique_ptr只能管理一个对象，shared_ptr可以管理多个对象，而weak_ptr并不拥有所管理的对象，只是一种弱引用。
2. **所管理的对象的所有权**：unique_ptr是独占性所有权，不能与其他unique_ptr共享同一个对象，shared_ptr可以共享所管理的对象，weak_ptr也可以共享所管理的对象，但不会改变对象的引用计数。
3. **所管理对象的内存释放方式**：unique_ptr在其所管理的对象被销毁时自动释放内存，shared_ptr采用计数引用的方式，当所有的shared_ptr被销毁时自动释放内存，weak_ptr不会释放内存。

总之，智能指针是一种非常实用的工具，可以极大地简化 C++ 内存管理的工作。然而，使用智能指针时也需要注意一些细节，例如循环引用的问题。



### 111什么是多态，什么是虚函数，实现原理

多态是指在面向对象的程序设计中，允许不同类的对象对同一消息作出响应。具体来说，可以通过基类指针或引用指向派生类对象，然后调用基类中定义的虚函数，实现对派生类不同的响应。

**虚函数是在基类中使用 virtual 关键字声明的成员函数**，**它允许在派生类中重写（override）该函数**，**从而实现多态**。在调用一个虚函数时，程序会根据当前对象的类型调用对应的函数实现，而不是单纯地调用基类中定义的函数。

虚函数的实现原理是采用虚函数表（vtable）和虚函数指针（vptr）来实现的。每个包含虚函数的对象，在内存中都会有一个指向虚函数表的指针（vptr），虚函数表中存储了该类所有虚函数的地址。当执行虚函数时，程序会先根据对象的vptr找到相应的虚函数表，再根据函数的位置索引调用相应的函数实现。



   

### 112 纯虚函数有什么用

纯虚函数是没有**函数体的虚函数**，在函数的声明语句后面加上 "=0" 就可以将其声明为纯虚函数。纯虚函数只有声明而没有定义，**因此必须在其派生类中实现才能使用**。

**纯虚函数的作用主要有两个：**

1. **实现接口类**：纯虚函数可以用来定义一个接口类，它的派生类需要实现这个接口，从而实现多态性。当我们需要让多个类共享相同的接口时，可以使用纯虚函数来定义一个抽象类作为接口，例如：

```
class Shape {
public:
    virtual double area() = 0;
    virtual double perimeter() = 0;
};

class Rectangle : public Shape {
public:
    double area() { /* 实现代码 */ }
    double perimeter() { /* 实现代码 */ }
};

class Circle : public Shape {
public:
    double area() { /* 实现代码 */ }
    double perimeter() { /* 实现代码 */ }
};
```

这里，Shape 是一个接口类，定义了图形的面积和周长的抽象方法，Rectangle 和 Circle 是其派生类，必须实现这些方法来实现 Shape 接口。

1. **提供一种默认实现：纯虚函数可以提供一种默认实现，让派生类可以选择是否重写这个函数**。例如：

```
class Base {
public:
    virtual void foo() = 0;
    virtual void bar() { /* 默认实现 */ }
};

class Derived : public Base {
public:
    void foo() { /* 实现代码 */ }
    // bar() 使用默认实现
};
```

这里，Base 是一个基类，定义了纯虚函数 foo() 和虚函数 bar()。Derived 是其派生类，必须实现 foo()，可以选择是否重写 bar()，默认使用 Base 中的实现。

总之，纯虚函数是**实现接口和提供默认实现的有效工具**，可以实现程序的抽象和多态性。

### 113  虚析函数有什么用

虚析函数的作用是在类的继承关系中正确释放资源，防止内存泄漏。

**当使用基类的指针或引用指向派生类的对象时，如果基类中的析构函数不是虚函数，那么在删除这个对象时，只会调用基类的析构函数，而不会调用派生类的析构函数，这会导致派生类中的资源无法得到正确释放，从而导致内存泄漏**。

而如果**将基类的析构函数声明为虚析函数，那么在删除派生类对象时，会先调用派生类的析构函数，然后在调用基类的析构函数，这样就可以确保派生类中的资源得到正确释放，避免内存泄漏。**

虚析函数的声明方法是在析构函数前加上关键字"virtual"，如下所示：

```
class Base {
public:
    virtual ~Base() {}
};

class Derived : public Base {
public:
    ~Derived() {}
};
```

注：由于虚析函数会引入虚函数表，因此在没有必要使用虚析函数的场景下，使用虚析函数会带来一些额外的开销。

#### 114vector底层实现，扩容时做了哪些事

先分配更大内存的空间，然后把内容复制过去，然后把指针移过去

### 115    map可以存储自定义类型的key吗，如何实现

可以存储自定义类型的key，但**需要指定一个比较函数**，告诉**map如何比较两个key的大小**。以下是一个示例：

```
#include <iostream>
#include <map>
#include <string>

struct Person {
    std::string name;
    int age;
};

bool operator<(const Person& p1, const Person& p2) {
    if (p1.name == p2.name) {
        return p1.age < p2.age;
    }
    return p1.name < p2.name;
}

int main() {
    std::map<Person, std::string> m;
    m[{ "Alice", 22 }] = "Student";
    m[{ "Bob", 25 }] = "Engineer";

    for (const auto& p : m) {
        std::cout << p.first.name << ", " << p.first.age << ": " << p.second << std::endl;
    }

    return 0;
}
```

在上面的示例中，我们定义了一个Person结构体，并且重载了小于号运算符，以便map可以比较两个Person对象的大小。注意，我们只需要重载小于号运算符，因为map默认使用小于号进行比较。然后我们定义了一个`std::map<Person, std::string>`类型的变量，并将两个Person对象作为key，与对应的value一起存储到map中。最后，我们遍历map，输出存储的数据。

相比于基本数据类型和标准库类型，使用自定义类型作为map的key时需要更多的考虑和实现工作。不过，只要重载了小于号运算符，就可以方便地使用自定义类型作为map的key了。

### 116  map底层的红黑树具体是怎样的，有几个指针…更细节的

Map底层的实现是基于红黑树的，具体来说，是一颗自平衡的二叉查找树，确保了插入、删除、查找等操作的时间复杂度为 O(log n)。

在C++ STL中，红黑树的定义在头文件中，它定义在std命名空间中。红黑树的实现是通过一个节点结构来实现的，每个节点包含以下属性：

1. **Key**: **存储节点的键值**
2. **Value: 存储节点的值**
3. **Left: 左子节点的指针**
4. **Right: 右子节点的指针**
5. **Parent:** **父节点的指针**
6. **Color: 节点的颜色，可以是红色或黑色**

通过这个节点结构，就可以构建一颗红黑树了。在红黑树中，每个节点都被涂上了黑色或红色，使得树的任何路径上都有相同数量的黑色节点。红色节点永远不能直接相连，而且根节点必须是黑色的。因此，这个红黑树满足以下性质：

1. 节点要么是黑色，要么是红色
2. 根节点是黑色的
3. 所有叶子节点（NIL）都是黑色的
4. 如果一个节点是红色的，则它的两个子节点都是黑色的
5. 对于任意节点而言，其到叶子节点（NIL）路径上包含相同数量的黑色节点

在实现上，节点的颜色一般用一个枚举类型来表示，比如：

```cpp
enum Color { RED, BLACK };
```

这样就可以方便地处理节点的颜色了。

对于每个节点，在插入、删除、查找等操作中，都需要根据它的颜色和位置来进行一些特殊处理，以维护红黑树的性质。比如，在插入节点时，需要考虑它的颜色和父节点的颜色，以及是否需要通过旋转操作来保持平衡。

总的来说，红黑树虽然看起来比较复杂，但是它的实现是非常优秀的，能够在保证时间复杂度的同时，具有较好的空间利用率。因此，在C++ STL中，map等容器的底层实现采用红黑树是非常合理的选择。

### 117四种智能指针，如何自己实现一个智能指针

四种智能指针是：

1. unique_ptr：独占所有权的智能指针，只有一个指针可以指向一个资源，销毁时自动释放。
2. shared_ptr：共享所有权的智能指针，多个指针可以指向同一个资源，计数器记录使用数量，最后一个指针释放时销毁资源。
3. weak_ptr：弱引用智能指针，只能从 shared_ptr 构造，不会增加计数器，不会造成循环引用。
4. auto_ptr：已经被废弃的智能指针，不能与标准容器等一起使用。

要自己实现一个智能指针，需要了解以下几点：

1. 智能指针的基本特征是什么，如何管理资源。
2. 如何使用 RAII（资源获取即初始化）的原则来确保资源的正确释放。
3. 内存管理的相关知识，如：new、delete、普通指针等。
4. C++11 中智能指针的实现方法，如：make_shared、enable_shared_from_this 等。

下面是一个简单的示例实现：

```cpp
template<typename T>
class SmartPtr {
public:
    explicit SmartPtr(T* ptr = nullptr) : ptr_(ptr) {}
    ~SmartPtr() { delete ptr_; }

    SmartPtr(const SmartPtr& other) = delete;
    SmartPtr& operator=(const SmartPtr& other) = delete;

    SmartPtr(SmartPtr&& other) noexcept : ptr_(other.ptr_) {
        other.ptr_ = nullptr;
    }

    SmartPtr& operator=(SmartPtr&& other) noexcept {
        if (this != &other) {
            delete ptr_;

            ptr_ = other.ptr_;
            other.ptr_ = nullptr;
        }
        return *this;
    }

    T* Get() const { return ptr_; }
    T& operator*() const { return *ptr_; }
    T* operator->() const { return ptr_; }
    operator bool() const { return ptr_ != nullptr; }

private:
    T* ptr_;
};
```

该智能指针为独占所有权指针，使用 delete 确保资源的释放，在移动语义中进行指针的转移。同时也禁止了复制语义的使用。

### 118shared_ptr是有引用计数吗，是在哪里计数的

是的，shared_ptr具有引用计数机制。引用计数是在堆上分配的引用计数对象中进行的，由SharedPointerControlBlock类实现，每个shared_ptr对象都有一个指向分配的控制块对象的指针。SharedPointerControlBlock跟踪指向相同资源的shared_ptr对象数量，并在不再有任何shared_ptr对象引用该资源时释放该资源。实际上，shared_ptr对象的析构函数将通过SharedPointerControlBlock来管理引用计数并释放相应的资源。

119unique_ptr和shared_ptr有什么区别，不能复制是为什么，能复制是为什么

### 120 std::move把左值变成右值，变量在内存中的位置怎么变化的

std::move 是把一个左值强制转换为右值引用的一个函数模板。**它不会改变变量所在内存位置，但会改变变量的值和类型。通过 std::move 转换后，该变量原本所指的对象的所有权会被转移给另一个变量（通常是一个右值引用）**。

在 C++ 中，一个左值表示一个具有名称的可修改的对象，而右值表示一个临时对象，常量或者原始类型的值。左值具有地址，而且是可以取地址的。右值没有地址，不能取地址。在某些情况下，我们需要将一个左值看作是右值来避免进行额外的拷贝或移动操作，这时就可以使用 std::move。std::move 的实现是通过将左值的地址强制转换为一个右值引用来实现的。这个右值引用指向原来存储在该地址处的值，该值现在的所有权被转移到了一个新的对象中。

例如，我们有一个字符串对象 str，如果我们想要把它的值转移到一个新的对象中，就可以使用 std::move：

```cpp
std::string str = "hello";
std::string new_str = std::move(str); // 转移 str 的值给 new_str
```

调用 std::move 后，str 不再拥有原来的值，而是变成了一个空字符串。new_str 则拥有了原来 str 的值。在这个过程中，str 和 new_str 变量所在的内存位置没有发生变化，只是原来的值所在的内存位置发生了变化。

需要注意的是，当一个对象的所有权被转移到另一个对象时，原来对象的状态是无法确定的，因此不要再尝试使用它。在使用 std::move 时，需要确保所操作的对象确实是具有可转移的状态，否则就可能会导致程序出错。

### 121    设计模式都有哪些，用过哪些，在什么场景下使用(未知)

设计模式是软件工程中的一种通用解决问题的方案，在面向对象设计和编程中十分常见。常见的设计模式有以下几种：

1. 创建型模式：**单例模式**、**工厂模式**、**抽象工厂模式**、建造者模式、原型模式。
2. 结构型模式：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
3. 行为型模式：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

我曾经使用过的设计模式有：

1. 单例模式：**应用于需要全局唯一实例的场景，比如资源池、日志记录器等。**
2. 工厂模式**：应用于需要根据不同的配置或其他条件创建不同类型的对象的场景。**
3. 观察者模式：**应用于需要一种松散耦合方式实现对象之间消息的传递和通信的场景，比如消息队列、事件系统**等。
4. 状态模式：应用于需要根据不同状态执行不同操作的场景。
5. 策略模式：应用于需要根据不同策略采取不同行动的场景，比如算法决策。

不同的设计模式适用于不同的场景，有些模式适用于复杂的应用场景，而有些模式适用于简单的场景。选择合适的设计模式可以提高代码的可读性、可维护性和易扩展性。

### 122 lambda表达式相关问题，闭包之类

Lambda表达式是一种匿名函数，它可以在代码中定义一个函数并返回它，而无需使用函数名称，这样可以使代码更加简洁和易于阅读。**闭包是指在一个函数内部定义的函数，该函数可以访问并修改其外部函数的变量。Lambda表达式可以创建闭包，因为它们可以访问其定义上下文中的变量。**

Lambda表达式通常用于函数式编程中，它可以作为参数传递给其他函数以及用于定义函数，例如在Python中，可以使用lambda表达式定义一个匿名函数，如下所示：

```
add = lambda x, y: x + y
```

这将创建一个名为add的函数，它接受两个参数x和y，并返回它们的和。此函数可以像任何其他函数一样使用，例如：

```
result = add(2, 3) # result is 5
```

闭包通常用于保护变量，以便它们不会在函数之外被修改。例如，在Python中，可以使用闭包实现一个计数器，如下所示：

```
def counter():
    count = 0
    def inner():
        nonlocal count
        count += 1
        return count
    return inner

c = counter()
print(c()) # 1
print(c()) # 2
print(c()) # 3
```

这将创建一个名为counter的函数，它返回一个inner函数。inner函数使用包含count变量的闭包，并在每次调用时将它增加1。因此，每次调用c函数时，它都会返回一个新的计数器值。

总之，lambda表达式和闭包是Python中的两个强大的功能，它们可以帮助我们更轻松地编写函数式代码和保护变量。

### 123      go和C++有什么不同

Go 和 C++ 是非常不同的两种编程语言，它们有以下区别：

1. 语法：Go 和 C++ 的语法风格很大不同，Go 语言具有类似于 C 语言的语法，同时也受到了 Pascal 和 Python 语言的影响。C++ 语言则更贴近于 C 语言，同时拥有了更多的面向对象编程的特性。
2. 内存管理：Go 语言的内存管理是通过垃圾回收来实现的，而 C++ 语言需要手动分配和释放内存。这使得 C++ 语言更加灵活，但也容易发生内存泄漏等问题，需要程序员自行负责内存管理。
3. 并发：Go 语言在设计之初就考虑到并发编程，并内置了 Go 协程、通道等特性，这使得 Go 语言在进行并发编程时非常方便。而在 C++ 语言中，需要使用线程库等辅助工具才能实现并发编程。
4. 性能：C++ 语言通常比 Go 语言更快，这是因为 C++ 语言使用的是编译器直接编译成机器码的方式，而 Go 语言是通过虚拟机或解释器来执行代码的，因此比 C++ 语言稍慢一些。
5. 库：C++ 语言拥有非常丰富的库，可以用来完成各种各样的任务，包括游戏开发、图形界面开发、科学计算等，而 Go 语言则缺乏这样的库，且社区相对不是很活跃。

总之，Go 和 C++ 是两种不同类型的编程语言，各有优缺点。选择何种语言，应该根据具体情况考虑。如果对于并发编程和开发 Web 应用等领域较为关注，那么应该更倾向于使用 Go 语言；而如果对于高性能编程、游戏开发等领域较为关注，那么使用 C++ 语言将会更加合适。

### 124  c和c++的区别

C和C++是两种不同的编程语言，它们有许多共同之处，但也存在一些重要的区别。下面是一些C和C++之间的主要区别：

1. C++是C的扩展，它包含所有C的特性，并添加了面向对象编程的特性，如类、继承、多态等。
2. C++支持函数重载，可以在同一范围内使用多个同名函数，但它们必须具有不同的参数列表。
3. C++支持引用类型，在C中只有指针类型。
4. C++具有异常处理机制，可以在程序出现错误时抛出异常并捕获它们，C不支持这种机制。
5. C++包括STL（Standard Template Library）标准模板库，它提供了许多现成的数据结构和算法，以便开发人员更轻松地编写代码。
6. C++支持名字空间，这是一种组织代码的方法，可以将不同的部分归类在不同的名字空间中，以避免命名冲突。

在使用C或C++时，需要根据具体的场景和需求进行选择。通常情况下，如果开发的是系统级应用或需要更高的性能，则使用C更为适合。如果要开发面向对象的应用程序或需要使用现成的数据结构和算法，则使用C++更加便利。

​      

### 126在函数调用中Call by Value方式 和Call by Reference方式有什么差别？对性能有什么影响？

在函数调用中，Call by Value和Call by Reference是两种不同的参数传递方式。

Call by Value方式是指将参数的值复制到函数的形参中，函数内部对形参的修改不会影响实参的值。这种方式在函数内部修改形参时，不会影响到函数外部的实参。

Call by Reference方式是指将参数的地址传递给函数，函数内部对形参的修改会影响到实参的值。这种方式在函数内部修改形参时，会影响到函数外部的实参。

Call by Value方式可以防止函数无意间修改外部变量的值，从而保证了程序的安全性，但是会产生额外的拷贝开销。Call by Reference方式可以减少拷贝的开销，但是会导致函数内部对外部变量的修改，需要注意使用的安全性。

对于性能方面，**Call by Value方式会产生额外的拷贝开销**，而**Call by Reference方式则不会产生拷贝的开销，但会增加额外的指针解引用操作**。因此，在大量函数调用的情况下，Call by Value方式可能会影响程序的性能。



### 127string的SSO模式

string的SSO（Short String Optimization，**短字符串优化**）模式是指对**于长度比较短的字符串，将其内容存储在string对象本身的栈空间或预留空间中，而不是在堆空间中分配存储空间**。

在C++11标准中，string类型的具体实现方式是由C++库实现定义的，该实现通常使用了SSO模式。具体来说，在VC++中，若字符串长度小于16，则将其存储在string对象的栈空间或预留空间中，长度大于等于16时则在堆空间中分配存储空间。在GCC或Clang中，这个值可以设置成其它的值，但默认值通常为15或16。

**使用SSO模式的好处是在满足一定条件下可以避免频繁的堆内存分配和释放，从而提高程序的性能。同时，因为短字符串的存储不需要额外的堆空间，因此可以降低内存碎片的问题，提高内存的利用率**。

需要注意的是，在使用SSO模式时需要权衡字符串长度和空间的分配，因为如果过多的字符串采用SSO模式，会占用过多的栈空间，可能导致栈溢出等问题。因此，具体的实现方式需要根据具体的场景和需求来进行选择。



### 130那为什么不用担心派生类会有多个析构函数(不会)

派生类的析构函数会继承基类的析构函数，同时也可以有自己的析构函数。当一个对象被销毁时，会首先调用其派生类的析构函数，然后再调用其基类的析构函数，这样可以确保被继承的对象会被正确、完全地释放。

在C++中，派生类的析构函数**并不会覆盖基类的析构函数**，**而是在基类的析构函数中调用了派生类的析构函数**。这样，**即使有多个派生类，也不会出现析构函数的重复定义问题。**

需要注意的是，**在使用虚析构函数时，派生类必须声明自己的析构函数为虚函数，这样才能保证在析构派生类对象时能够正确调用其自己的析构函数**。如果没有正确使用虚析构函数可能会导致内存泄漏和程序崩溃等问题。

### 131      多态中基类的virtual函数的用途，含有纯虚函数的类是否可以用来声明对象？

在C++中，**基类的virtual函数是用于实现多态的机制的**。多态是指在程序运行时根据对象的实际类型确定调用哪个函数的特性。**通过将基类的函数设为virtual，可以在程序运行时动态绑定，实现多态**。

当一个基类的函数被声明为虚函数后，派生类中相同函数的声明也自动成为虚函数，无论有没有使用virtual关键字。这样，可以在基类指针或引用指向派生类对象时，通过调用虚函数实现动态绑定。

**纯虚函数是一个没有实现的虚函数，它只是一个占位符，需要被派生类实现。含有纯虚函数的类被称为抽象类，不能直接用来声明对象。抽象类只能用作接口，它的派生类必须实现纯虚函数才能被实例化**。可以通过定义纯虚函数来强制派生类实现某些函数，从而增加程序的可靠性和拓展性。

因此，含有纯虚函数的类不能直接用来声明对象，但是可以通过它的派生类来实例化对象。只有当派生类实现了所有纯虚函数后，才能被实例化。含有纯虚函数的类可以用来定义抽象接口，使得派生类实现该接口时必须重载此虚函数。同时也为了实现多态性，可以将基类的函数设置为纯虚函数，强制派生类实现该函数，从而实现多态的机制。



### 133    STL如何进行内存管理

在STL中，内存的分配和释放是由**allocator负责**完成的。allocator是STL中的一个对象，它提供了一些方法来分配和释放内存。

每一个STL容器都有一个默认的allocator，通常情况下，我们不需要显式地使用allocator进行内存管理，STL容器会自动调用默认的allocator来管理内存，并且在容器销毁时自动释放内存。

但是，有时候需要使用自定义的allocator来管理内存，例如在特殊的内存分配场景下，例如需要定制内存池来提高效率和降低内存碎片等。

使用自定义的allocator需要注意以下几点：

1. **自定义的allocator必须符合allocator接口的规范，即实现allocate()和deallocate()两个方法。**
2. **如果自定义的allocator不是无状态（stateless）的，则需要提供一个构造函数，并将其作为容器的第二个参数。**
3. **自定义的allocator需要支持复制，因为某些STL容器会进行拷贝操作。**
4. **自定义的allocator需要确保分配的内存是对齐的，以提高程序的效率。**
5. **在使用自定义的allocator时，需要保证其线程安全性，以防止在多线程环境下出现问题。**

总之，STL中的allocator提供了一种方便和高效的内存分配和释放机制，同时也支持自定义allocator来满足特殊的需求。使用STL容器和allocator可以有效地提高程序的效率和可维护性。

### 134 STL容器的线程安全问题

在C++的STL（标准模板库）中，容器是常用的数据结构之一，它包括 vector、list、deque、map 等，提供了便捷的存储和访问机制。但是，STL容器在多线程环境下存在线程安全问题。

**在并发环境下，多个线程可能同时对同一个STL容器进行读写操作，如果没有对容器进行合理的保护，就会导致数据竞争和线程不安全问题。**

STL没有提供原生的线程安全容器，但是可以通过以下方式解决STL容器的线程安全问题：

1. 互斥锁机制：使用互斥锁（mutex）对容器进行加锁和解锁操作，防止多线程同时访问。
2. 读写锁机制：使用读写锁（read-write lock）对容器进行加锁和解锁操作，允许多个读操作同时进行，但是只允许一个写操作进行。
3. 原子操作：使用内置的原子操作（atomic）对容器进行操作，它们是线程安全的，可以避免数据竞争和锁的开销。
4. 使用第三方线程安全库：例如boost库和Qt库提供了线程安全容器的封装和实现。

需要注意的是，线程安全的容器会引入额外的开销和复杂性，因此在单线程环境下，可以使用STL原生的容器来提高效率。在多线程环境下，应该根据具体的需求和性能要求选择合适的线程安全机制。

### 135      std::function与std::bind

**std::function和std::bind都是C++11中引入的函数对象（function object）。**

std::function是一个通用的**函数对象包装器****，可以将任意类型的可调用对象（函数、函数指针、lambda表达式等）封装成一个可调用的对象，并且可以像普通函数一样调用**。std::function支持返回值、参数类型和个数的自动推导，可以方便地实现回调、事件处理等功能。

std::bind是一个**函数模板**，可以将一个可调用对象和其参数绑定起来，返回一个函数对象。bind函数的第一个参数是可调用对象，后面跟随若干个实参，表示要绑定的参数。绑定后的函数对象可以像普通函数一样调用，但是会自动传入绑定的参数。**bind函数支持占位符**（std::placeholders::_1、std::placeholders::_2等）和**可变参数模板**，可以方便地实现函数柯里化（currying）和参数重排。

总之，std::function和std::bind都是**函数对象包装器，可以方便地实现回调、事件处理等功能**。**std::function适用于将任意类型的可调用对象封装成一个可调用的对象**，**std::bind适用于将一个可调用对象和其参数绑定起来，返回一个函数对象**。在实际开发中，可以根据具体需求来选择使用哪个库函数。

### 137  strcpy和memcpy

strcpy()函数用于将**字符串从源位置复制到目标位置**。它仅复制字符串，而不拷贝任何其他数据。

memcpy()函数用于**从源位置复制固定大小的内存块到目标位置**。它可以复制任何类型的数据，包括字符串。

### 139虚函数机制

虚函数机制是一种实现多态的机制，它使得不同类的对象可以通过相同的接口调用相同的函数，而实际被调用的函数则是根据对象的实际类型决定的。虚函数表是一种数据结构，用于存储指向虚函数的指针，每个类都有一个虚函数表，虚函数表中存储了指向该类虚函数的指针。

### 140 重载、重写、隐藏的区别

重载（overload）、重写（override）和隐藏（hide）是C++中常见的几个术语。

重载是指在**同一个作用域中**定义的**函数名相同**但是**参数类型、个数或顺序不同**。编译器通过函数的参数列表进行区分，选择对应的函数进行调用。重载可以提高代码的复用性和灵活性。

重写是指在**派生类中重写基类的虚函数**，使得派生类可以覆盖基类的虚函数实现，实现多态特性。在派生类中，通过使用与基类相同的函数名、参数列表和返回类型来重写基类的虚函数。通过动态绑定，可以在运行时根据对象的实际类型选择执行哪个函数。重写只能发生在虚函数上。

**隐藏是指在派生类中定义一个与基类函数名称相同的非虚函数，导致基类的同名函数被隐藏（而不是重写）。**在派生类中，使用与基类相同的函数名，但是参数列表和返回类型不一定相同来定义一个新的函数。当在派生类中调用同名函数时，将只能访问派生类的函数。如果需要调用基类的同名函数，则需要使用作用域操作符“::”来指定。





### 142 工厂模式，观察者模式，单例模式？

​             工厂模式：是一种创建型设计模式，用于创建对象而无需指定将要创建的对象的确切类。它提供了一个通用接口，使客户端能够在不了解其产品实际类的情况下创建对象。

观察者模式：是一种行为型设计模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。当主题对象发生变化时，它的所有观察者都会自动收到通知并更新。

单例模式：是一种创建型设计模式，它能够保证一个类只有一个实例，并提供一个全局访问该实例的点。它为整个系统提供了一个唯一的入口，控制着整个系统的资源。

### 143  哈希冲突的产生原因

哈希冲突的产生原因是由于哈希函数算法不同的输入可能会产生相同的哈希值，从而造成冲突。

### 144**空间配置器也问到了**

空间配置器（Allocator）是 STL 中的一部分，用于管理内存的分配和释放。空间配置器是一种内存池技术，它通过从内存池中分配内存（称为“chunk”）提高了分配和释放内存的效率。

空间配置器管理的内存区域分为两部分：静态空间（以空间配置器类的静态变量方式进行定义），和动态空间（通过malloc或new操作从系统申请得到）。

空间配置器包含了两个主要的接口：allocate 和 deallocate。allocate 用于分配内存，deallocate 用于释放内存。在分配内存时，空间配置器首先从静态内存池中查找是否有可用的 chunk，如果没有，就从系统申请动态内存，并将其切分成许多小块（称为 chunk），每个 chunk 的大小都为 2 的倍数。allocate 从空闲链表中找到一个大小合适的 chunk，如果没有合适大小的块，则将动态内存申请再切分成小块。

空间配置器还可以处理内存对齐问题。由于部分硬件对内存地址的对齐有要求，因此空间配置器可以确保所分配的内存满足对齐要求，避免内存访问异常等问题。

总之，空间配置器是 STL 中的重要组成部分，它优化了内存分配和释放的效率，并提供了对内存对齐的处理。

### 145内存布局

内存布局通常分为以下几个部分：

1. 栈（Stack）：用于存放函数的参数值、局部变量的值以及函数的返回地址等信息。栈的大小在编译时就已经确定。
2. 堆（Heap）：用于手动分配和释放内存。堆的大小不固定，可以动态调整。
3. 全局/静态存储区（Global/Static Storage）：用于存储全局变量和静态变量（包括初始化和未初始化的静态变量）。该区域在程序启动时分配，并一直存在于整个程序的生命周期中。
4. 代码区（Code/text Segment）：用于存储可执行代码。代码区通常是只读的，不允许进行写操作。
5. 常量区（Constant Segment）：用于存储字符串常量和其他常量数据。该区域通常也是只读的。
6. 动态链接库区（Dynamic Linking Libraries Segment）：用于存储动态链接库，也称为共享对象（shared object）。

不同的操作系统和编译器可能会有不同的内存布局，但是基本的结构通常是相似的。了解内存布局可以帮助程序员更好地理解内存管理和调试问题。

### 146设计模式：职责链模式

职责链模式是一种行为设计模式，**它允许一个请求在一条链上传递，直到有对象处理它为止。 请求者只需要知道链的开头，而不需要知道链的其他部分。 这种模式使每个对象都有机会处理请求，并且可以根据自己的条件决定是否处理请求。**

### 147什么是虚假唤醒：pthread_cond_signal

虚假唤醒（Spurious wakeup）是一种多线程编程中的特殊现象，指的是条件变量（pthread_cond_t）在未被调用 signal 或 broadcast 函数的情况下，线程阻塞在该条件变量上时，却被唤醒。条件变量被唤醒的原因可以是定时器超时、操作系统级别的中断或其它一些随机的事件。

在多线程编程中，为了防止因虚假唤醒而导致的竞争条件和错误，使用条件变量时一般需要在条件变量前加锁，并在 signal 或 broadcast 函数调用后，再在之前加锁的情况下检查条件变量的条件是否满足。如果条件未满足，则继续等待。

在 pthread 库中，虚假唤醒的产生是由于 signal 或 broadcast 函数的实现机制所导致的。对**于 signal 函数而言，它会选择一个等待在条件变量上的线程，将其唤醒，但是，并不保证一定将等待在条件变量上的所有线程都唤醒**；对于 **broadcast 函数**而言，它会将所有等待在条件变量上的线程都唤醒，**但是**，**并不保证线程唤醒的顺序**。

因此，在使用 **pthread_cond_signal 和 pthread_cond_broadcast** 函数时，需要**注意**以下几点：

1. 在检查条件是否满足时，需要在之前加锁的情况下进行。
2. **在等待条件变量时，要使用 while 循环进行检查，而不是 if 判断，以防止因虚假唤醒而导致的竞争条件和错误**。
3. 在使用 pthread_cond_broadcast 函数时，需要在之前加锁的情况下进行，以避免多个线程同时竞争解锁的情况发生。

总之，对于多线程编程中的虚假唤醒问题，需要注意几个关键点，即加锁、检查条件以及使用 while 循环等。以提高程序的可靠性和稳定性。