# 3.内存管理(星空)

### 1.操作系统在读磁盘的时候会额外多读一些到内存中，但是最后这些数据也没用到，有什么改善的方法吗？

改进LRU算法：
传统LRU算法存在的问题一：**预读失效**,导致缓存命中率下降.

**什么是预读失效**：传统LRU算法，会把多余数据放到LRU链表头部，而当内存空间不够的时候，还需要把末尾的页淘汰掉。如果这些多余的预读数据一直不被访问到，就会出现**问题**：
不会被访问的预读数据占用了LRU链表前排的位置，而末尾淘汰的数据，有可能是热点数据，被淘汰掉就降低了cache命中，增加了磁盘IO

**改进思路**：最好就是让预读页停留在内存里的时间要尽可能的短，让真正被访问的页才移动到 LRU 链表的头部，从而保证真正被读取的热数据留在内存里的时间尽可能长。

这里拿Linux操作系统和mysql的解决办法举例子：
1.Linux 操作系统实现两个了 LRU 链表：
活跃 LRU 链表（active_list）
和非活跃 LRU 链表（inactive_list）；

2.MySQL 的 Innodb 存储引擎是在一个 LRU 链表上划分来 2 个区域：young 区域 和 old 区域。

**都是将数据分为了冷数据和热数据，然后分别进行 LRU 算法**

------

### 2.批量读数据的时候，可能会把热点数据挤出去，有什么改善的方法呢

改进LRU算法：
传统LRU算法存在的问题二：缓存污染,导致缓存命中率下降

什么是缓存污染：LRU 算法只要数据被访问一次，就将数据加入活跃 LRU 链表（或者 young 区域），**这种 LRU 算法进入活跃 LRU 链表的门槛太低了**！正式因为门槛太低，才导致在发生缓存污染的时候，很容就将原本在活跃 LRU 链表里的热点数据淘汰了



解决思路：**只要我们提高进入到活跃 LRU 链表（或者 young 区域）的门槛，就能有效地保证活跃 LRU 链表（或者 young 区域）里的热点数据不会被轻易替换掉**

这里拿Linux操作系统和mysql的解决办法举例子：

1.Linux 操作系统**：在内存页被访问**第二次**的时候，才将页从 inactive list 升级到 active list 里。

2.MySQL Innodb：在内存页被访问第二次的时候，并不会马上将该页从 old 区域升级到 young 区域，因为还要进行停留在 old 区域的时间判断：

- 如果第二次的访问时间与第一次访问的时间**在 1 秒内**（默认值），那么该页就**不会**被从 old 区域升级到 young 区域；
- 如果第二次的访问时间与第一次访问的时间**超过 1 秒**，那么该页就**会**从 old 区域升级到 young 区域；

**通过提高了进入 active list （或者 young 区域）的门槛后，就很好了避免缓存污染带来的影响。**

------



### 3.为什么操作系统需要内存管理和虚拟内存，除了给进程分配内存和防止进程间相互影响，还有什么作用

内存管理和虚拟内存

1.可以给程序提供更大的可用内存。

2.多进程内存空间共享

3.访问保护，安全作用

内存管理通过对内存的分配和回收，以及程序页面的置换，来提高系统的内存利用率



------

### 4.除了OOM，内存满了之后会有什么处理？

OOM Killer 机制会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，OOM Killer 会继续杀死占用物理内存较高的进程，直到释放足够的内存位置。

------



### 5.在4GB物理内存的机器上，申请8G内存会怎样

- 在 32 位操作系统，因为进程理论上最大能申请 3 GB 大小的虚拟内存，所以直接申请 8G 内存，会申请失败。
- 在 64位 位操作系统，因为进程理论上最大能申请 128 TB 大小的虚拟内存，即使物理内存只有 4GB，申请 8G 内存也是没问题，因为申请的内存是虚拟内存。如果这块虚拟内存被访问了，要看系统有没有 Swap 分区：
  - 如果没有 Swap 分区，因为物理空间不够，进程会被操作系统杀掉，原因是 OOM（内存溢出）；
  - 如果有 Swap 分区，即使物理内存只有 4GB，程序也能正常使用 8GB 的内存，进程可以正常运行；





------



### 6.那么到底什么是虚拟内存地址 ？

虚拟内存地址是一种逻辑地址，这种技术可以使系统可以操作超出实际物理内存大小的地址空间。

使得程序员可以利用更大的内存而不用担心物理内存的限制。



------



### 7.Linux 内核为啥要引入虚拟内存而不直接使用物理内存 ？

虚拟内存可以解决当物理内存不够用时，利用磁盘空间模拟出更多的内存空间，以保证系统运行

可以提高系统可靠性和灵活性。

提升内存的使用效率，

减轻内存管理的负担。

------



### 8.虚拟内存空间到底长啥样？

![image.png](3.内存管理(星空).assets/ffb6e1727e2289f142f6a2a6291cd68c.png)

1.但是用户态虚拟内存空间中的代码段并不是从 0x0000 0000 地址开始的，而是从 0x0804 8000 地址开始。0x0000 0000 到 0x0804 8000 这段虚拟内存地址是一段**不可访问的保留区**，因为在大多数操作系统中，数值比较小的地址通常被认为不是一个合法的地址，这块小地址是不允许访问的。比如在 C 语言中我们通常会将一些无效的指针设置为 NULL，指向这块不允许访问的地址。

2.保留区的上边就是**代码段和数据段**，它们是从程序的二进制文件中直接加载进内存中的，BSS 段中的数据也存在于二进制文件中，因为内核知道这些数据是没有初值的，所以在二进制文件中只会记录 BSS 段的大小，在加载进内存时会生成一段 0 填充的内存空间。

3紧挨着 BSS 段的上边就是我们经常使用到的**堆空间**，从图中的红色箭头我们可以知道在堆空间中地址的增长方向是从**低地址到高地址**增长。

内核中使用 **start_brk 标识堆的起始位置**，brk 标识堆当前的结束位置。当**堆申请新的内存空间**时，只需要将 **brk 指针增加对应的大小**，**回收地址时减少对应的大小**即可。比如当我们通过 malloc 向内核申请很小的一块内存时（128K 之内），就是通过改变 brk 位置实现的。

堆空间的上边是一段**待分配区域，用于扩展堆空间的使用**。

接下来就来到了**文件映射与匿名映射区域**。进程运行时所依赖的动态链接库中的代码段，数据段，BSS 段就加载在这里。还有我们调用 mmap 映射出来的一段虚拟内存空间也保存在这个区域。**注意：在文件映射与匿名映射区的地址增长方向是从高地址向低地址增长**。

接下来用户态虚拟内存空间的最后一块区域就是**栈空间了**，在这里会保存函数运行过程所需要的局部变量以及函数参数等函数调用信息。**栈空间中的地址增长方向是从高地址向低地址增长**。每次进程申请新的栈地址时，其地址值是在减少的。

在内核中使用 **start_stack 标识栈的起始位置**，RSP 寄存器中保存栈顶指针 stack pointer，RBP 寄存器中保存的是栈基地址。

在栈空间的下边也有一段待分配区域用于扩展栈空间，在栈空间的上边就是内核空间了，进程虽然可以看到这段内核空间地址，但是就是不能访问。这就好比我们在饭店里虽然可以看到厨房在哪里，但是厨房门上写着 “厨房重地，闲人免进” ，我们就是进不去。











### 9.内核如何管理虚拟内存？

task_struct 结构



```c
struct task_struct {
        // 进程id
	    pid_t				pid;
        // 用于标识线程所属的进程 pid
	    pid_t				tgid;
        // 进程打开的文件信息
        struct files_struct		*files;
        // 内存描述符表示进程虚拟地址空间
        struct mm_struct		*mm;

        .......... 省略 .......
}
```

```c
struct mm_struct {
    unsigned long task_size;    /* size of task vm space */
    unsigned long start_code, end_code, start_data, end_data;
    unsigned long start_brk, brk, start_stack;
    unsigned long arg_start, arg_end, env_start, env_end;
    unsigned long mmap_base;  /* base of mmap area */
    unsigned long total_vm;    /* Total pages mapped */
    unsigned long locked_vm;  /* Pages that have PG_mlocked set */
    unsigned long pinned_vm;  /* Refcount permanently increased */
    unsigned long data_vm;    /* VM_WRITE & ~VM_SHARED & ~VM_STACK */
    unsigned long exec_vm;    /* VM_EXEC & ~VM_WRITE & ~VM_STACK */
    unsigned long stack_vm;    /* VM_STACK */

       ...... 省略 ........
}
```



### 10.什么又是物理内存地址 ？如何访问物理内存？

CPU 与内存之间的数据交互是通过总线（bus）完成的

首先 CPU 芯片中的总线接口会在总线上发起读事务（read transaction）。 该读事务分为以下步骤进行：

1. CPU 将物理内存地址 A 放到系统总线上。随后 IO bridge 将信号传递到存储总线上。
2. 主存感受到存储总线上的地址信号并通过存储控制器将存储总线上的物理内存地址 A 读取出来。
3. 存储控制器通过物理内存地址 A 定位到具体的存储器模块，从 DRAM 芯片中取出物理内存地址 A 对应的数据 X。
4. 存储控制器将读取到的数据 X 放到存储总线上，随后 IO bridge 将存储总线上的数据信号转换为系统总线上的数据信号，然后继续沿着系统总线传递。
5. CPU 芯片感受到系统总线上的数据信号，将数据从系统总线上读取出来并拷贝到寄存器中。

以上就是 CPU 读取内存数据到寄存器中的完整过程。

 CPU 向内存写入数据过程

我们现在假设 CPU 要将寄存器中的数据 X 写到物理内存地址 A 中。同样的道理，CPU 芯片中的总线接口会向总线发起写事务（write transaction）。写事务步骤如下：

1. CPU 将要写入的物理内存地址 A 放入系统总线上。
2. 通过 IO bridge 的信号转换，将物理内存地址 A 传递到存储总线上。
3. 存储控制器感受到存储总线上的地址信号，将物理内存地址 A 从存储总线上读取出来，并等待数据的到达。
4. CPU 将寄存器中的数据拷贝到系统总线上，通过 IO bridge 的信号转换，将数据传递到存储总线上。
5. 存储控制器感受到存储总线上的数据信号，将数据从存储总线上读取出来。
6. 存储控制器通过内存地址 A 定位到具体的存储器模块，最后将数据写入存储器模块中的 8 个 DRAM 芯片中。

## 



### 11.简单说一下C语言中和C++中内存管理的区别

管理内存一般指程序员申请和释放堆空间内存，

在C中，我们使用malloc进行堆空间管理，这个空间一般是不会初始化的，除非是使用calloc等申请空间函数，

C++中对内存管理的方式有很多，首先是堆空间的申请，C++中常用new/delete组合进行堆空间申请，并且它是主动对申请空间进行了置0的初始化动作的，但是实际上，其底层也是使用malloc实现的；

其次C++中对栈空间管理经常采用RAII的方式，即智能指针进行栈空间管理

### 12.栈区和堆区

| 堆区                       | 栈区                             |
| -------------------------- | -------------------------------- |
| malloc/new                 |                                  |
| 程序员可以操作             | 程序员不能访问                   |
| 存储函数及其参数，局部变量 | 存储由程序员分配和释放的动态内存 |
| 系统自动分配释放           | 程序员手动分配释放               |
|                            |                                  |

