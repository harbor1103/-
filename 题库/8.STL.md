## 8.STL

### 1 如果vector插入或者删除元素后，迭代器的变化

------

如果vector插入或删除元素，所有指向容器内元素的迭代器都会失效，需要重新获取指向容器内元素的迭代器。



### 2 vector底层实现是什么数据结构

------

动态数组+三个指针



### 3 vector和map做查询的时候，哪个更快些

------



**测试方法：**

给vector和map容器中分别塞入1,000,000个数据（顺序插入，有序的），然后设定一个查找目标，vector顺序遍历查找，map用key查找，对比查找时间。使用高精度定时器计时。

1、unordered_map比map快

2、vector查找14次，基本和unordered_map查找一次耗时相当（int和string做key差别不大）

3、string作key，vector查询100次，基本和map查询一次耗时相当；int作key，vector查询28次，基本和map查询一次耗时相当

4、boost的unordered_map和map与STL的效率基本相同

**结论：**

在实际应用中，vector是更快的，因为它拥有更快的查询速度。当查询大量数据时，map更适合，因为它可以更有效地根据键值对查询数据

### 4 stl容器的遍历

------

1  下标遍历  

2  迭代器遍历 begin()和end()

3  for和auto的结合



### 5 push_back和emplace_back

------

push_back函数将一个元素加到vector的最后面

原理：先生成相应类型的对象，然后再通过将对象拷贝或者移动构造复制到容器的尾部，然后释放原来对象的空间

emplace_back直接在尾部实例化相应类型的对象，少了拷贝或者移动构造的过程。



push_back是在容器的末尾添加一个新的元素，emplace_back是在容器的末尾创建一个新元素，而不是添加一个已存在的元素。

push_back是将一个已存在的元素拷贝到容器中，emplace_back是在容器中直接构造一个元素，而不需要拷贝构造





### 6 list和vector的区别

------

list底层实现是双向链表，vector是动态数组

list不支持下标访问，vector支持

list可以在头部进行插入元素，vector不行。



### 7 map底层用的红黑树，unorder_map用的哈希，为什么不前者用哈希，后者用红黑树？

------

| 红黑树--map          | 哈希--unorderedmap                   |
| -------------------- | ------------------------------------ |
| **查找效率高**，有序 | 查找速度快，但无法提供有序的查找结果 |
| 插入和删除效率低     | **插入和删除效率高**                 |
| 有序                 | 无序                                 |
| 可以范围查找         | 不可以范围查找                       |





### 8 STL中的常用容器有哪些

------

序列式容器：vector、list、deque、queue、forward_list
关联式容器：set、map、multiset、multimap、

无序关联式容器：、unordered_set、unordered_map 。。。 。。。

容器适配器 priority queue，stack ，queue

​             

### 9 vector的迭代器失效

------

动态数组带来的内存空间转移，迭代器本质是指针，导致扩容过程中，实际内存位置已经变更，迭代器指向转移前的位置

就是比如for循环pushback，当pushback扩容capacity的时候，迭代器没有指向新的容器，还指向老的容器，那么就迭代器失效了



### 10 vector的自动扩容

------

表面：动态数组，size和capacity管理
底层：_start/_end/_endofcapacity的三指针



### 11vector的删除

------

vector的erase方法可以删除vector容器中的指定元素，也可以删除指定区间的元素。erase的使用方式如下：

1. vector.erase(iterator); //删除指定的元素
2. vector.erase(iterator_first, iterator_last); //删除指定的区间元素

vector的erase函数的返回值是一个迭代器，指向被删除元素的下一个元素。



### 13map和set的底层实现是什么数据结构

------

红黑树



### 14unordered_map和unordered_set底层实现是什么数据结构

------

哈希表



### 15单例/其他设计模式

------

代码直接背，考虑完全单例和NoCopyable

\

```
#include<iostream>

using namespace std;

class Single

{

​    public:

​    Single(const Single &)=delete;

​    Single & operator=(const Single &)=delete;

​    static Single & init()

​    {

​        if(nullptr==_p)

​        {

​            _p=new Single();

​        }

​        return *_p;

​    }

​    static void del()

​    {

​        if(_p)

​        {

​            delete _p;

​        }

​    }

​    void put(int x)

​    {

​        _x=x;

​    }

​    void show()

​    {

​        cout<<_x<<endl;

​    }

​    private:

​    Single(){}

​    int _x;

​    static Single  * _p;

};

Single * Single::_p=nullptr;

int main()

{

​    Single & p=Single::init();

​    p.put(1);

​    p.show();

​    Single::del();

}
```



### 16vector的动态体现

------





### 18map的实现原理

------

红黑树



### 19stl当中vector、list、map在内存中的数据结构有什么区别

------

vector，三个指针维护的动态数组

list，双向链表

map，红黑树



### 20vector、list在添加删除的效率方面有什么不同

------

vector是在尾部添加，O(1)的时间复杂度

list添加可以在任何位置添加，但是要遍历链表，O(n)的时间复杂度



### 21自己实现unordered_map的话，你会考虑到什么问题呢？

------

如果我要实现自己的`unordered_map`，会考虑以下几个问题：

1. 哈希函数的设计：哈希函数要能够将键映射为桶的索引，同时要满足均匀性和独立性，以尽可能减小哈希冲突的概率。
2. 冲突处理：即使哈希函数设计良好，冲突仍然是不可避免的，因此我需要考虑如何处理冲突。常见的方法有开放寻址法和链式哈希法。
3. 内存管理：我需要考虑如何管理桶和节点的内存，以确保内存使用效率和正确性。一般来说，我可以使用`new`和`delete`运算符手动分配和释放内存，或者使用`std::allocator`进行动态内存分配和管理。
4. 各种操作的实现：`unordered_map`支持插入、删除、查找等各种操作，对于每个操作都需要实现对应的函数。
5. 效率优化：我需要尽可能优化哈希表的性能，例如，桶的大小应该合适，哈希冲突的概率应该尽可能小，每个节点的内存分配应该尽可能紧凑等。
6. 一致性和异常安全：当出现异常时，我必须保证哈希表的状态不会被破坏，以确保代码的健壮性和可维护性。
7. STL兼容性：最后一个问题是，我需要确保我的实现符合STL标准，并且可以与其他STL容器一起无缝使用。

### 22 stl中的unordered_map和unordered_set有什么区别呢？

------

unordered_map支持下标访问

unordered_map存储的是键值对，unordered_set存储的是key



### 23string赋值是深拷贝还是浅拷贝

------

在 C++ 中， `string` 的赋值操作是进行深拷贝的。

当使用赋值操作符（`=`）或者 `assign()` 函数将一个 `string` 对象赋值给另一个 `string` 对象时，新的 `string` 对象会创建一个新的字符串，并将赋值的字符串复制到新的内存地址中。这意味着对新的 `string` 对象进行更改不会影响原始的字符串。

具体来说， `string` 类在内部维护一个指向字符缓冲区的指针，当赋值时， `string` 会根据该指针指向的缓冲区的内容创建一个新的字符缓冲区，并将原始字符串复制到新的缓冲区中。这种方法确保了对新的 `string` 对象的更改不会影响原始的字符串。

### 24clear和erase的区别？vector和deque的区别？

clear()`和`erase()`的主要区别在于，`clear()` 删除整个字符串，而 `erase()` 删除字符串的一部分，且 `erase()` 演示更多的灵活性，允许你指定要删除的部分。

   

vecotr动态数组，只能在尾部插入

deQue是中控器数组，可以在头尾插入

### 25vector扩容原理，

| **t<=容量-个数**             | **不扩容**                             |
| ---------------------------- | -------------------------------------- |
| **容量-个数<t<个数，**       | **按照**  **2\*个数**         **扩容** |
| **容量-个数<t, 个数<t<容量** | **按照**  **t+个数**         **扩容**  |
| **t>容量**                   | **按照**  **t+个数**         **扩容**  |



### 26用过字典吗？

在 C++ STL 中，有两种常用的字典实现：`map` 和 `unordered_map`。



### 27hash与crypt的用途。

`hash` 和 `crypt` 是两个不同的概念：

- `hash`：**指将任意长度的数据**（通常是消息或密码）**通过一个特定的算法**，**转换为一段固定长度的数据（**通常是一串位于 0~255 之间的二进制数）。`hash` 函数具有不可逆性，即无法从 `hash` 值反推出原始数据，通常用于数据完整性验证、数据加密、随机数生成等场景。
- `crypt`：**指密码学中的一类技术****，主要用于数据加密和安全传输**。`crypt` 通常使用一对密钥对数据进行加密和解密，其中一个密钥为公开密钥（public key），另一个密钥为私有密钥（private key）。公开密钥用于数据加密，私有密钥用于数据解密，通常用于保护数据的机密性和身份认证。

在实际应用中，`hash` 和 `crypt` 都有广泛的用途：

- `hash`：常见的 `hash` 函数包括 MD5、SHA-1、SHA-256 等，它们在数据完整性验证、密码存储和比较、随机数生成等方面都有广泛的应用。例如，网站的密码通常需要经过 `hash` 处理存储在数据库中，用户登录时将输入的密码进行 `hash` 处理后与数据库中的值比较，从而实现密码的验证。又如，在分布式存储系统中，`hash` 函数可以将数据映射到特定节点的存储位置，以实现数据的分散存储和快速定位。
- `crypt`：常见的 `crypt` 技术包括对称加密和非对称加密，它们在数据传输和数据存储中都有广泛的应用。例如，在电子商务中，客户端和服务器之间的数据传输通常需要进行加密，以保护用户的个人信息和支付信息不被窃取。又如，在数字签名中，发送方可以使用私有密钥对数字签名进行加密，接收方使用公开密钥对数字签名进行解密和验证，以确保数据的完整性和来源可信。

需要注意的是，虽然 `hash` 和 `crypt` 都可以实现数据加密和安全传输，但它们的实现机制和应用场景是不同的，需要根据具体的需求来选择合适的方案。一般来说，**hash`主要用于数据完整性验证和随机数生成等场景**，而 `crypt` **主要用于数据加密和安全传输。**



### 28vector什么时候会扩容，扩容时是内存怎么去实现的，如何将vector申请的空间的大小设为0（resize之后在shrint_to_fit?）

可以通过调用 `vector` 的 `clear` 或 `resize` 函数来将申请的空间的大小设为 0。

- `clear` 函数：将 `vector` 中的元素清空，并将大小设置为 0。

```cpp
std::vector<int> vec{1, 2, 3, 4, 5};
vec.clear(); // 清空 vec 中的元素，并将大小设置为 0
```

- `resize` 函数：将 `vector` 的大小调整为指定的大小，并清空多余的元素。如果指定的大小小于当前大小，则会截断多余的元素；如果指定的大小大于当前大小，则会在末尾插入默认值的元素。

```cpp
std::vector<int> vec{1, 2, 3, 4, 5};
vec.resize(0); // 将 vec 的大小设置为 0，并清空多余的元素
```

需要注意的是，`clear` 和 `resize` 函数只是将 `vector` 中的元素清空或大小设置为 0，但并不会释放申请的内存空间。如果需要将 `vector` 申请的内存空间也释放掉，可以调用 `shrink_to_fit` 函数。

- `shrink_to_fit` 函数：将 `vector` 的容量调整为大小所需的最小值。

```cpp
std::vector<int> vec{1, 2, 3, 4, 5};
vec.clear(); // 清空 vec 中的元素，并将大小设置为 0
vec.shrink_to_fit(); // 释放 vec 申请的内存空间
```

需要注意的是，调用 `shrink_to_fit` 函数并不保证会释放所有的内存空间，因为 `vector` 的实现可能会保留一部分空间以备后续的添加操作。

### 29请讲述一下迭代器模式



不太清楚

### 32      map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？

红黑树的特点使得它非常适合实现**关联**容器，比如 map 和 set。其中，**map 通过红黑树实现了一种键值对的关联关系，set 通过红黑树实现了一种去重的集合关系。**

具体来说，**在 map 中，红黑树的节点包含了键值对，通过比较键的大小来实现排序和查找。在 set 中，红黑树的节点只包含了元素值，通过比较元素值的大小来实现去重和查找。**

为什么使用红黑树呢？主要有以下几个原因：

- 红黑树具有自平衡的特性，简化了平衡树的操作，且能够在保证平衡的同时，保持较好的效率。
- 红黑树在所有操作中的时间复杂度均为 O(log n)，比其他平衡树的时间复杂度更优秀。

总之，红黑树是一种非常适合实现**关联容器**的数据结构，能够在保证平衡的同时，维护容器的查找、插入和删除等操作的高效性。

红黑树实现了一种自平衡的二叉搜索树，具有以下特点：

- 节点被标记为红色或黑色，根节点和所有叶子节点（NULL）是黑色的。
- 如果一个节点是红色的，则其子节点必须是黑色的。
- 从任意一个节点到其每个叶子节点的所有路径都包含相同数量的黑色节点。
- 新插入的节点被插入为红色节点，并且需要通过旋转和变色来维护红黑树的平衡性。
- 在查找、插入和删除操作中，红黑树的时间复杂度为 O(log n)。